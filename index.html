<!DOCTYPE html>
<html lang="ko" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTG 사용자 매뉴얼</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js CDN for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Inter 폰트 추가 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 활성 섹션에 대한 스타일 (JavaScript로 제어) */
        aside a.active {
            background-color: #e0e7ff; /* bg-indigo-100 */
            color: #4f46e5; /* text-indigo-700 */
            font-weight: 600;
        }
        section {
            padding-top: 6rem; /* 헤더 높이만큼 패딩 */
            margin-top: -6rem; /* 헤더 높이만큼 마진 상쇄 */
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- 고정 헤더 -->
    <header class="fixed top-0 left-0 md:left-64 right-0 bg-white shadow-md z-40">
        <div class="px-8 py-4">
            <h1 class="text-2xl font-bold text-gray-800">BTG (Batch Translator for Gemini) - 사용자 매뉴얼</h1>
        </div>
    </header>

    <!-- 고정 사이드바 (데스크탑) -->
    <aside class="w-64 fixed inset-y-0 left-0 bg-white border-r border-gray-200 p-6 overflow-y-auto z-50 transform -translate-x-full md:translate-x-0 transition-transform duration-300 ease-in-out hidden md:block" id="sidebar">
        <h2 class="text-xl font-semibold text-indigo-600 mb-6">목차</h2>
        <nav class="space-y-2" id="toc">
            <a href="#intro" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">소개</a>
            <a href="#features" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">주요 기능</a>
            <a href="#getting-started" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">시작하기</a>
            <a href="#gui-guide" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">GUI 사용법</a>
            <ul class="ml-4 space-y-1 border-l border-gray-200">
                <li><a href="#gui-tab1" class="block py-1.5 px-3 text-sm text-gray-600 hover:text-gray-900">설정 및 번역</a></li>
                <li><a href="#gui-tab2" class="block py-1.5 px-3 text-sm text-gray-600 hover:text-gray-900">용어집 관리</a></li>
                <li><a href="#gui-tab3" class="block py-1.5 px-3 text-sm text-gray-600 hover:text-gray-900">실행 로그</a></li>
            </ul>
            <a href="#code-library" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">코드 라이브러리</a>
            <a href="#config-file" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">설정 파일 (config.json)</a>
            <a href="#ai-chat-guide" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">AI 상담사</a>
            <a href="#license" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">라이선스</a>
        </nav>
    </aside>

    <!-- 모바일 햄버거 버튼 -->
    <button class="md:hidden fixed top-4 left-4 z-50 p-2 bg-white rounded-md shadow" id="menu-button">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
    </button>
    
    <!-- 모바일 사이드바 (숨겨짐) -->
    <aside class="w-64 fixed inset-y-0 left-0 bg-white border-r border-gray-200 p-6 overflow-y-auto z-50 transform -translate-x-full md:translate-x-0 transition-transform duration-300 ease-in-out md:hidden" id="mobile-sidebar">
        <h2 class="text-xl font-semibold text-indigo-600 mb-6">목차</h2>
        <nav class="space-y-2" id="mobile-toc">
             <a href="#intro" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">소개</a>
            <a href="#features" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">주요 기능</a>
            <a href="#getting-started" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">시작하기</a>
            <a href="#gui-guide" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">GUI 사용법</a>
            <ul class="ml-4 space-y-1 border-l border-gray-200">
                <li><a href="#gui-tab1" class="block py-1.5 px-3 text-sm text-gray-600 hover:text-gray-900">설정 및 번역</a></li>
                <li><a href="#gui-tab2" class="block py-1.5 px-3 text-sm text-gray-600 hover:text-gray-900">용어집 관리</a></li>
                <li><a href="#gui-tab3" class="block py-1.5 px-3 text-sm text-gray-600 hover:text-gray-900">실행 로그</a></li>
            </ul>
            <a href="#code-library" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">코드 라이브러리</a>
            <a href="#config-file" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">설정 파일 (config.json)</a>
            <a href="#ai-chat-guide" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">AI 상담사</a>
            <a href="#license" class="block py-2 px-3 rounded-lg hover:bg-gray-100 text-gray-700">라이선스</a>
        </nav>
    </aside>
    <!-- 오버레이 -->
    <div class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden md:hidden" id="overlay"></div>


    <!-- 메인 콘텐츠 -->
    <main class="md:ml-64 p-8 pt-24 bg-gray-100 min-h-screen">
        
        <!-- 소개 -->
        <section id="intro">
            <h2 class="text-3xl font-bold text-gray-900 border-b pb-2 mb-6">소개</h2>
            <p class="text-lg text-gray-700 leading-relaxed">
                BTG (Batch Translator for Gemini)는 Google Gemini API를 사용하여 대용량 텍스트를 효율적으로 번역하는 배치 번역 도구입니다.
                특히 소설 번역에 특화되어 있으며, 용어집(Glossary) 관리와 병렬 처리를 통해 일관성 있고 빠른 번역을 제공합니다.
                사용자는 GUI(그래픽 사용자 인터페이스) 또는 CLI(명령줄 인터페이스)를 통해 프로그램을 사용할 수 있습니다.
            </p>
        </section>

        <!-- 주요 기능 -->
        <section id="features">
            <h2 class="text-3xl font-bold text-gray-900 border-b pb-2 mb-6">주요 기능</h2>
            <ul class="list-disc list-inside space-y-3 text-gray-700 leading-relaxed">
                <li>
                    <strong>배치 번역:</strong> 여러 텍스트 파일을 한 번에 또는 큰 파일을 청크(조각) 단위로 나누어 번역합니다.
                </li>
                <li>
                    <strong>병렬 처리:</strong> 다중 스레드를 사용하여 여러 청크를 동시에 번역하여 속도를 향상시킵니다.
                </li>
                <li>
                    <strong>작업 이어하기:</strong> 메타데이터 파일을 기반으로 중단된 번역 작업을 마지막 지점부터 재개할 수 있습니다.
                </li>
                <li>
                    <strong>용어집 관리:</strong> 텍스트에서 용어집(고유명사, 지명 등)을 JSON 파일로 자동 추출하고, 번역 시 동적으로 주입하여 일관성을 유지합니다.
                </li>
                <li>
                    <strong>콘텐츠 안전 재시도:</strong> API의 콘텐츠 검열로 인해 번역이 실패할 경우, 해당 청크를 더 작게 나누어 자동으로 재시도합니다.
                </li>
                <li>
                    <strong>다중 인증 지원:</strong>
                    <ul class="list-decimal list-inside ml-6 mt-2 space-y-1">
                        <li><strong>Gemini Developer API:</strong> 여러 개의 API 키를 등록하여 키 순환(Rotation) 및 속도 제한(Rate Limit)에 대응합니다.</li>
                        <li><strong>Vertex AI:</strong> 서비스 계정(SA) JSON 파일 또는 ADC를 통한 GCP 인증을 지원합니다.</li>
                    </ul>
                </li>
                <li>
                    <strong>고급 프롬프트:</strong> 번역 품질을 높이기 위한 프리필(Prefill) 시스템 지침 및 대화 내역 캐싱을 지원합니다.
                </li>
                <li>
                    <strong>GUI 및 CLI:</strong> 사용 편의성을 위한 GUI와 자동화를 위한 CLI를 모두 제공합니다.
                </li>
            </ul>
        </section>

        <!-- 시작하기 -->
        <section id="getting-started">
            <h2 class="text-3xl font-bold text-gray-900 border-b pb-2 mb-6">시작하기</h2>
            
            <h3 class="text-2xl font-semibold text-gray-800 mt-6 mb-4">1. 요구 사항 설치</h3>
            <p class="text-gray-700 leading-relaxed mb-4">
                프로그램 실행에 필요한 Python 라이브러리들을 설치합니다. 프로젝트 루트 디렉토리에서 다음 명령을 실행하세요.
            </p>
            <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-x-auto font-mono text-sm"><code>pip install -r requirements.txt</code></pre>

            <h3 class="text-2xl font-semibold text-gray-800 mt-6 mb-4">2. 설정 파일 (`config.json`) 준비</h3>
            <p class="text-gray-700 leading-relaxed mb-4">
                프로그램을 처음 실행하면 <code>config.json</code> 파일이 생성됩니다. 또는 기본 설정을 복사하여 직접 만들 수 있습니다.
                가장 중요한 설정은 API 인증 정보입니다.
            </p>
            
            <div class="bg-indigo-50 border-l-4 border-indigo-400 p-4 rounded-r-lg my-4">
                <h4 class="font-bold text-indigo-800">두 가지 인증 방식:</h4>
                <ul class="list-disc list-inside ml-4 text-indigo-700 space-y-2 mt-2">
                    <li>
                        <strong>Gemini Developer API (권장):</strong>
                        <code>config.json</code> 파일의 <code>"api_keys"</code> 리스트에 하나 이상의 Gemini API 키를 입력합니다.
                        <pre class="bg-gray-900 text-white p-2 rounded-md text-sm mt-2"><code>"api_keys": ["YOUR_API_KEY_1", "YOUR_API_KEY_2"]</code></pre>
                    </li>
                    <li>
                        <strong>Vertex AI:</strong>
                        <code>"use_vertex_ai"</code>를 <code>true</code>로 설정하고, <code>"service_account_file_path"</code>에 서비스 계정 JSON 파일 경로를 입력한 뒤, <code>"gcp_project"</code>와 <code>"gcp_location"</code>을 설정합니다.
                    </li>
                </ul>
            </div>

            <h3 class="text-2xl font-semibold text-gray-800 mt-6 mb-4">3. 프로그램 실행</h3>
            <p class="text-gray-700 leading-relaxed mb-4">
                설정이 완료되면 GUI 또는 CLI를 실행할 수 있습니다.
            </p>
            
            <h4 class="text-xl font-semibold text-gray-800 mt-4 mb-2">GUI 실행</h4>
            <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-x-auto font-mono text-sm"><code>python main_gui.py</code></pre>

            <h4 class="text-xl font-semibold text-gray-800 mt-4 mb-2">CLI 도움말 확인</h4>
            <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-x-auto font-mono text-sm"><code>python main_cli.py --help</code></pre>
        </section>

        <!-- GUI 사용법 -->
        <section id="gui-guide">
            <h2 class="text-3xl font-bold text-gray-900 border-b pb-2 mb-6">GUI 사용법</h2>
            <p class="text-gray-700 leading-relaxed mb-6">
                <code>python main_gui.py</code>를 실행하면 메인 창이 열립니다. 프로그램은 세 개의 탭으로 구성되어 있습니다.
            </p>

            <!-- 탭 1: 설정 및 번역 -->
            <h3 id="gui-tab1" class="text-2xl font-semibold text-gray-800 mt-6 mb-4">설정 및 번역 탭</h3>
            <p class="text-gray-700 leading-relaxed mb-4">
                이 탭에서 모든 번역 설정을 관리하고 번역 작업을 시작합니다.
            </p>
            <div class="grid md:grid-cols-2 gap-6">
                <!-- 좌측 컬럼 -->
                <div class="bg-white p-6 rounded-lg shadow-sm border">
                    <h4 class="text-xl font-bold text-indigo-700 mb-4">주요 설정</h4>
                    <ul class="space-y-4">
                        <li>
                            <strong>API 및 인증:</strong><br>
                            사용할 인증 방식을 선택합니다. <code>Vertex AI 사용</code> 체크박스로 모드를 전환할 수 있습니다. 각 모드에 맞는 인증 정보(API 키 목록 또는 서비스 계정 파일)를 입력하세요. <code>새로고침</code> 버튼으로 사용 가능한 모델 목록을 불러올 수 있습니다.
                        </li>
                        <li>
                            <strong>파일 및 처리:</strong><br>
                            <code>파일 추가</code>로 번역할 파일(들)을 목록에 추가합니다. 목록에서 파일을 여러 개 선택하여 한 번에 처리(배치 번역)할 수 있습니다. <code>출력 파일</code> 경로는 입력 파일이 하나일 때 사용되며, 여러 파일일 경우 <code>[원본파일]_translated.txt</code> 형식으로 자동 생성됩니다.
                        </li>
                        <li>
                            <strong>처리 설정:</strong><br>
                            - <code>청크 크기</code>: 텍스트를 나눌 크기 (문자 수).
                            - <code>최대 작업자 수</code>: 동시 번역 스레드 수 (병렬 처리).
                            - <code>분당 요청 수 (RPM)</code>: API 속도 제한(Rate Limit)에 맞춰 분당 요청 수를 조절합니다.
                        </li>
                    </ul>
                </div>
                <!-- 우측 컬럼 -->
                <div class="bg-white p-6 rounded-lg shadow-sm border">
                    <h4 class="text-xl font-bold text-indigo-700 mb-4">프롬프트 및 고급 설정</h4>
                    <ul class="space-y-4">
                        <li>
                            <strong>언어 설정:</strong><br>
                            - <code>소설/번역 출발 언어</code>: 원본 텍스트의 언어 코드 (예: <code>ja</code>, <code>en</code>). <code>auto</code>로 설정 시 자동 감지합니다.
                            - <code>언어 자동감지 실패 시 폴백</code>: <code>auto</code> 설정이 실패할 경우 사용할 기본 언어.
                        </li>
                        <li>
                            <strong>프리필(Prefill) 설정:</strong><br>
                            <code>프리필 번역 사용</code> 시, 모델에 <code>시스템 지침</code>과 <code>캐시된 히스토리</code>(JSON 형식의 대화 내역)를 먼저 제공하여 번역의 톤앤매너와 일관성을 향상시킬 수 있습니다.
                        </li>
                         <li>
                            <strong>번역 프롬프트:</strong><br>
                            실제 번역 요청에 사용될 메인 프롬프트입니다. <code>{{slot}}</code>은 번역할 텍스트 조각으로, <code>{{glossary_context}}</code>는 용어집 내용으로 자동 대체됩니다.
                        </li>
                        <li>
                            <strong>콘텐츠 안전 재시도:</strong><br>
                            API가 콘텐츠 검열로 번역을 거부할 경우, <code>청크 분할 재시도 사용</code>을 체크하면 자동으로 해당 텍스트를 더 작게 나누어 다시 시도합니다.
                        </li>
                    </ul>
                </div>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-sm border mt-6">
                <h4 class="text-xl font-bold text-indigo-700 mb-4">작업 실행</h4>
                <ul class="list-disc list-inside space-y-2 text-gray-700">
                    <li><strong>설정 저장/불러오기:</strong> 현재 UI의 모든 설정을 <code>config.json</code>에 저장하거나 불러옵니다.</li>
                    <li><strong>번역 시작:</strong> 입력 파일 목록에 있는 모든 파일을 대상으로 번역 작업을 시작합니다. 작업 내역이 있다면 이어하기 여부를 묻습니다.</li>
                    <li><strong>실패 청크 재시도:</strong> 메타데이터에 기록된 실패한 청크들만 다시 번역합니다.</li>
                    <li><strong>중지:</strong> 현재 진행 중인 번역 작업을 중단 요청합니다.</li>
                </ul>
            </div>

            <!-- 탭 2: 용어집 관리 -->
            <h3 id="gui-tab2" class="text-2xl font-semibold text-gray-800 mt-10 mb-4">용어집 관리 탭</h3>
            <p class="text-gray-700 leading-relaxed mb-4">
                번역의 일관성을 위한 용어집(고유명사, 지명 등)을 생성하고 관리합니다.
            </p>
            <div class="bg-white p-6 rounded-lg shadow-sm border">
                <h4 class="text-xl font-bold text-indigo-700 mb-4">핵심 워크플로우</h4>
                <ol class="list-decimal list-inside space-y-3 text-gray-700">
                    <li>
                        <strong>입력 파일 선택:</strong> (선택 사항) <code>설정 및 번역</code> 탭에서 용어집을 추출할 소설/텍스트 파일을 목록에 추가하고 선택합니다.
                    </li>
                    <li>
                        <strong>용어집 추출:</strong> <code>선택한 입력 파일에서 용어집 추출</code> 버튼을 클릭합니다. API가 텍스트를 분석하여 용어집 초안(JSON)을 생성합니다.
                        <ul class="list-disc list-inside ml-6 mt-2 space-y-1 text-sm">
                            <li><strong>샘플링 비율:</strong> 텍스트 전체가 아닌 일부만 샘플링하여 빠르게 추출할 수 있습니다. (100%로 설정 시 전체 분석)</li>
                            <li><strong>고급 설정:</strong> <code>추출 온도</code>나 <code>사용자 재정의 추출 프롬프트</code>를 통해 추출 품질을 조절할 수 있습니다.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>추출 결과 확인 및 편집:</strong> 추출된 JSON이 하단 텍스트 영역에 표시됩니다. <code>용어집 편집</code> 버튼을 눌러 새 창에서 항목(키워드, 번역어, 등장 횟수 등)을 추가/수정/삭제할 수 있습니다.
                    </li>
                    <li>
                        <strong>저장:</strong> <code>JSON 저장</code> 버튼을 누르거나 편집기 창에서 저장하여 용어집을 <code>.json</code> 파일로 보관합니다. <code>JSON 파일 경로</code>에 이 파일 경로가 설정되어 있는지 확인합니다.
                    </li>
                    <li>
                        <strong>번역 시 사용:</strong> <code>동적 용어집 주입 활성화</code> 체크박스를 선택하면, <code>설정 및 번역</code> 탭에서 번역을 시작할 때 이 용어집을 자동으로 프롬프트(<code>{{glossary_context}}</code>)에 주입합니다.
                    </li>
                </ol>
            </div>
            <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-r-lg my-4">
                <h4 class="font-bold text-yellow-800">용어집 파일 경로의 중요성</h4>
                <p class="text-yellow-700 mt-2">
                    <code>용어집 JSON 파일 경로</code>에 지정된 파일이 <strong>용어집 추출</strong>(시드 파일로 사용)과 <strong>동적 주입</strong>(번역 시 참고) 모두에 사용됩니다. 추출 후 원하는 용어집 파일을 이 경로에 설정해야 합니다.
                </p>
            </div>
             <div class="bg-white p-6 rounded-lg shadow-sm border mt-6">
                <h4 class="text-xl font-bold text-indigo-700 mb-4">용어집 편집기 기능</h4>
                <p class="text-gray-700 leading-relaxed mb-4">
                    <code>용어집 편집</code> 버튼을 누르면 나타나는 창에서 다음 작업을 수행할 수 있습니다:
                </p>
                <ul class="list-disc list-inside space-y-2 text-gray-700">
                    <li><strong>항목 추가/삭제/수정:</strong> 용어집 목록을 관리합니다. (키워드, 번역된 키워드, 도착 언어, 등장 횟수)</li>
                    <li><strong>선택한 용어 치환:</strong> (주의!) 현재 선택된 용어집 항목의 <code>키워드</code>를 <code>설정 및 번역</code> 탭의 <strong>입력 파일</strong> 내에서 <code>번역된 키워드</code>로 <strong>전부 치환</strong>합니다. 원본 파일을 직접 수정합니다.</li>
                    <li><strong>모든 용어 치환:</strong> (매우 주의!) 용어집에 있는 <strong>모든 항목</strong>에 대해 입력 파일 내의 <code>키워드</code>를 <code>번역된 키워드</code>로 <strong>전부 치환</strong>합니다.</li>
                </ul>
            </div>

            <!-- 탭 3: 실행 로그 -->
            <h3 id="gui-tab3" class="text-2xl font-semibold text-gray-800 mt-10 mb-4">실행 로그 탭</h3>
            <p class="text-gray-700 leading-relaxed mb-4">
                번역 작업이나 용어집 추출 중 발생하는 상세한 로그를 실시간으로 확인할 수 있습니다. 오류가 발생하거나 작업이 느릴 경우 이 탭의 메시지를 확인하세요.
            </p>
        </section>

        <!--
        <section id="cli-guide">
... (CLI 가이드 주석 처리됨) ...
        </section>
        -->

        <!-- 코드 라이브러리 (신규) -->
        <section id="code-library">
            <h2 class="text-3xl font-bold text-gray-900 border-b pb-2 mb-6">코드 라이브러리</h2>
            <p class="text-gray-700 leading-relaxed mb-6">
                AI 상담사가 사용자의 질문에 답변하기 위해 참고하는 핵심 소스 코드입니다.
            </p>

            <!-- app_service.py -->
            <h4 class="text-xl font-semibold text-gray-800 mt-6 mb-2">app/app_service.py (일부)</h4>
            <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-x-auto font-mono text-sm" data-filename="app/app_service.py"><code># app_service.py
# ... (내용 생략) ...
class AppService:
    # ... (내용 생략) ...
    def load_app_config(self, runtime_overrides: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        # ... (내용 생략) ...
        try:
            # 1. 파일 및 기본값으로부터 기본 설정 로드
            config_from_manager = self.config_manager.load_config()
            self.config = config_from_manager # 파일/기본값으로 시작

            # 2. 제공된 runtime_overrides가 있다면, self.config에 덮어쓰기
            if runtime_overrides:
                self.config.update(runtime_overrides)
            # ... (내용 생략) ...
            if should_initialize_client:
                try:
                    # ... (내용 생략) ...
                    self.gemini_client = GeminiClient(
                        auth_credentials=auth_credentials_for_gemini_client,
                        project=project_to_pass_to_client,
                        location=gcp_location,
                        requests_per_minute=rpm_value
                    )
                # ... (내용 생략) ...
            if self.gemini_client:
                self.translation_service = TranslationService(self.gemini_client, self.config)
                self.glossary_service = SimpleGlossaryService(self.gemini_client, self.config) # Changed to SimpleGlossaryService
            # ... (내용 생략) ...
            return self.config
        except Exception as e:
            # ... (내용 생략) ...
            raise BtgConfigException(f"설정 로드 오류: {e}", original_exception=e) from e

    def start_translation(
        self,
        input_file_path: Union[str, Path],
        output_file_path: Union[str, Path],
        # ... (내용 생략) ...
        retranslate_failed_only: bool = False # 실패 청크 재번역 모드
    ) -> None:
        # ... (용어집 동적 로딩 로직 생략) ...
        
        thread = threading.Thread(
            target=self._translation_task, # 실제 번역 로직을 별도 메서드로 분리
            args=(input_file_path, output_file_path, progress_callback, status_callback, tqdm_file_stream, retranslate_failed_only),
            daemon=not blocking # blocking 모드가 아닐 때만 데몬 스레드로 설정
        )
        thread.start()

        if blocking:
            thread.join() # blocking 모드일 경우 스레드가 끝날 때까지 대기

    def _translation_task( # start_translation의 스레드 실행 로직을 이 메서드로 이동
        self,
        input_file_path: Union[str, Path],
        output_file_path: Union[str, Path],
        # ... (내용 생략) ...
    ):
        # ... (내용 생략) ...
        try:
            # ... (메타데이터 로드 및 해시 비교 로직 생략) ...
            
            file_content = read_text_file(input_file_path_obj)
            # ... (내용 생략) ...
            all_chunks: List[str] = self.chunk_service.create_chunks_from_file_content(file_content, self.config.get("chunk_size", 6000))
            total_chunks = len(all_chunks) 
            # ... (메타데이터 생성 및 이어하기 로직 생략) ...

            chunks_to_process_with_indices: List[Tuple[int, str]] = []
            # ... (번역할 청크 결정 로직 생략) ...
            
            self.executor = ThreadPoolExecutor(max_workers=max_workers)
            try:
                future_to_chunk_index: Dict[Any, int] = {}
                for i, chunk_text in chunks_to_process_with_indices:
                    # ... (중지 요청 확인) ...
                    future = self.executor.submit(self._translate_and_save_chunk, i, chunk_text,
                                            chunked_output_file_path,
                                            total_chunks, 
                                            input_file_path_obj, progress_callback)
                    future_to_chunk_index[future] = i
                
                for future in as_completed(future_to_chunk_index.keys()):
                    # ... (중지 요청 확인 및 결과 처리) ...
            finally:
                # ... (Executor 종료) ...

            # ... (결과 병합 및 후처리 로직 생략) ...
        except Exception as e:
            # ... (예외 처리) ...
        finally:
            # ... (작업 상태 플래그 정리) ...

    def _translate_and_save_chunk(self, chunk_index: int, chunk_text: str,
                            # ... (인자 생략) ...
                            ) -> bool:
        # ... (로그 및 변수 초기화) ...
        try:
            # ... (중지 요청 확인) ...
            if not self.translation_service:
                raise BtgServiceException("TranslationService가 초기화되지 않았습니다.")

            use_content_safety_retry = self.config.get("use_content_safety_retry", True)
            # ... (설정 로드) ...
                
            if use_content_safety_retry:
                translated_chunk = self.translation_service.translate_text_with_content_safety_retry(
                    chunk_text, max_split_attempts, min_chunk_size
                )
            else:
                translated_chunk = self.translation_service.translate_text(chunk_text)
            
            # ... (중지 요청 확인) ...

            with self._file_write_lock:
                save_chunk_with_index_to_file(chunked_output_file, chunk_index, translated_chunk)
            
            success = True
        except (BtgTranslationException, BtgApiClientException, Exception) as e:
            # ... (예외 처리 및 실패 기록) ...
            success = False
        finally:
            with self._progress_lock:
                if not self.stop_requested:
                    # ... (진행률 및 메타데이터 업데이트) ...
            return success
</code></pre>

            <!-- domain/translation_service.py -->
            <h4 class="text-xl font-semibold text-gray-800 mt-6 mb-2">domain/translation_service.py (일부)</h4>
            <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-x-auto font-mono text-sm" data-filename="domain/translation_service.py"><code># translation_service.py
# ... (내용 생략) ...
class TranslationService:
    def __init__(self, gemini_client: GeminiClient, config: Dict[str, Any]):
        self.gemini_client = gemini_client
        self.config = config
        self.chunk_service = ChunkService()
        self.glossary_entries_for_injection: List[GlossaryEntryDTO] = [] 
        # ... (내용 생략) ...
        if self.config.get("enable_dynamic_glossary_injection", False):
            self._load_glossary_data()
        # ... (내용 생략) ...

    def _construct_prompt(self, chunk_text: str) -> str:
        prompt_template = self.config.get("prompts", "Translate to Korean: {{slot}}")
        # ... (내용 생략) ...
        final_prompt = prompt_template

        # ... (언어 설정 및 용어집 주입 로직 생략) ...
        if self.config.get("enable_dynamic_glossary_injection", False) and \
           self.glossary_entries_for_injection and \
           "{{glossary_context}}" in final_prompt: 
            
            # ... (청크 내용 기반 관련 용어집 필터링 로직 생략) ...
            
            formatted_glossary_context = _format_glossary_for_prompt(
                relevant_entries_for_chunk, max_entries, max_chars
            )
            final_prompt = final_prompt.replace("{{glossary_context}}", formatted_glossary_context)
        else:
             # ... (용어집 컨텍스트 없음 처리) ...
        
        final_prompt = final_prompt.replace("{{slot}}", chunk_text)
        return final_prompt

    def translate_text(self, text_chunk: str, stream: bool = False) -> str:
        # ... (내용 생략) ...
        api_prompt_for_gemini_client: Union[str, List[genai_types.Content]]
        api_system_instruction: Optional[str]

        if self.config.get("enable_prefill_translation", False):
            # ... (프리필 로직: 시스템 지침 및 히스토리 구성) ...
            api_system_instruction = self.config.get("prefill_system_instruction", "")
            # ... (히스토리 변환) ...
            api_prompt_for_gemini_client = list(prefill_cached_history)
            api_prompt_for_gemini_client.append(
                genai_types.Content(role="user", parts=[genai_types.Part.from_text(text=str(current_chunk_user_prompt_str))])
            )
        else:
            # ... (표준 모드: 프롬프트 문자열) ...
            api_system_instruction = None 
            api_prompt_for_gemini_client = self._construct_prompt(text_chunk) 

        try:
            translated_text_from_api = self.gemini_client.generate_text(
                prompt=api_prompt_for_gemini_client,
                model_name=self.config.get("model_name", "gemini-2.0-flash"),
                generation_config_dict={
                    "temperature": self.config.get("temperature", 0.7),
                    "top_p": self.config.get("top_p", 0.9)
                },
                thinking_budget= self.config.get("thinking_budget", None),
                system_instruction_text=api_system_instruction,
                stream=stream 
            )
            # ... (결과 검증) ...
        except (GeminiContentSafetyException, GeminiAllApiKeysExhaustedException, GeminiRateLimitException, Exception) as e:
            # ... (예외 처리 및 BtgTranslationException/BtgApiClientException으로 래핑) ...
            raise BtgTranslationException(f"번역 중 알 수 없는 오류: {e}", original_exception=e) from e
        
        return translated_text_from_api.strip()
    
    def translate_text_with_content_safety_retry(
        self, 
        text_chunk: str, 
        # ... (인자 생략) ...
    ) -> str:
        try:
            # 1차 시도: 전체 청크 번역
            return self.translate_text(text_chunk)
        except BtgTranslationException as e:
            # ... (콘텐츠 안전 문제일 경우 _translate_with_recursive_splitting 호출) ...
            return self._translate_with_recursive_splitting(
                text_chunk, max_split_attempts, min_chunk_size, current_attempt=1
            )

    def _translate_with_recursive_splitting(
        self,
        # ... (인자 생략) ...
    ) -> str:
        # ... (최대 시도/최소 크기 확인) ...
        
        # ... (청크 분할 로직) ...
        sub_chunks = self.chunk_service.split_chunk_recursively(
            text_chunk,
            # ... (인자 생략) ...
        )
        # ... (분할 실패 시 문장 기반 분할) ...

        translated_parts = []
        for i, sub_chunk in enumerate(sub_chunks):
            try:
                # ... (중지 요청 확인) ...
                translated_part = self.translate_text(sub_chunk.strip(), stream=True)
                translated_parts.append(translated_part)
            except BtgTranslationException as sub_e:
                # ... (콘텐츠 안전 문제일 경우 재귀 호출, 그 외는 오류 메시지 삽입) ...
        
        return " ".join(translated_parts)
</code></pre>

            <!-- infrastructure/gemini_client.py -->
            <h4 class="text-xl font-semibold text-gray-800 mt-6 mb-2">infrastructure/gemini_client.py (일부)</h4>
            <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-x-auto font-mono text-sm" data-filename="infrastructure/gemini_client.py"><code># gemini_client.py
# ... (내용 생략) ...
class GeminiClient:
    # ... (예외 패턴 및 변수 정의) ...

    def __init__(self,
                 auth_credentials: Optional[Union[str, List[str], Dict[str, Any]]] = None,
                 project: Optional[str] = None,
                 location: Optional[str] = None,
                 requests_per_minute: Optional[float] = None):
        
        # ... (인증 모드 감지 및 설정: API_KEY, VERTEX_AI) ...
        
        if isinstance(auth_credentials, list) and all(isinstance(key, str) for key in auth_credentials):
            # --- 다중 API 키 모드 ---
            self.api_keys_list = [key.strip() for key in auth_credentials if key.strip()]
            self.auth_mode = "API_KEY"
            # ... (키별 클라이언트 풀 생성) ...
        elif isinstance(auth_credentials, str):
            # --- 단일 API 키 또는 SA JSON 문자열 ---
            try:
                # ... (JSON 파싱 시도) ...
                if isinstance(parsed_json, dict) and parsed_json.get("type") == "service_account":
                    service_account_info = parsed_json
                else: 
                    self.api_keys_list = [auth_credentials.strip()]
            # ... (예외 처리) ...
        # ... (Vertex AI 설정 로직) ...

    def _apply_rpm_delay(self):
        # ... (요청 속도(RPM) 제어를 위한 지연 로직) ...

    def generate_text(
        self,
        prompt: Union[str, List[genai_types.Content]], 
        model_name: str,
        # ... (인자 생략) ...
        system_instruction_text: Optional[str] = None, 
        # ... (인자 생략) ...
        stream: bool = False
    ) -> Optional[Union[str, Any]]: 
        # ... (클라이언트 및 모델명 유효성 검사) ...

        # ... (프롬프트를 List[Content] 형식으로 변환) ...

        total_keys = len(self.api_keys_list) if self.auth_mode == "API_KEY" and self.api_keys_list else 1
        attempted_keys_count = 0

        while attempted_keys_count < total_keys: # API 키 회전 루프
            # ... (초기화) ...
            while current_retry_for_this_key <= max_retries: # 재시도 루프
                try:
                    self._apply_rpm_delay() # RPM 지연 적용
                    
                    # ... (generation_config 및 safety_settings(OFF) 구성) ...
                    
                    if system_instruction_text and system_instruction_text.strip():
                        final_generation_config_params['system_instruction'] = system_instruction_text
                    
                    # ... (thinking_budget 설정) ...
                    
                    forced_safety_settings = [
                        # ... (모든 카테고리 HARM_BLOCK_THRESHOLD_OFF 설정) ...
                    ]
                    # ... (내용 생략) ...
                    
                    if stream:
                        response = self.client.models.generate_content_stream(
                            # ... (인자 전달) ...
                        )
                        # ... (스트림 결과 취합) ...
                    else:
                        response = self.client.models.generate_content(
                            # ... (인자 전달) ...
                        )
                        # ... (비스트림 결과 파싱) ...
                    
                    # ... (결과 반환: 텍스트 또는 JSON) ...

                except GeminiContentSafetyException:
                    raise # 콘텐츠 안전 예외는 즉시 전파
                except Exception as e:
                    # ... (오류 유형(RateLimit, InvalidRequest 등) 감지) ...
                    if self._is_invalid_request_error(e):
                        break # 현재 키 포기 (키 회전 시도)
                    elif self._is_rate_limit_error(e):
                        # ... (할당량 소진 시 즉시 break, 그 외는 재시도) ...
                    # ... (기타 예외 재시도) ...
            
            attempted_keys_count += 1
            if attempted_keys_count < total_keys and self.auth_mode == "API_KEY":
                if not self._rotate_api_key_and_reconfigure():
                    # ... (키 회전 실패 처리) ...
            # ... (Vertex 모드 오류 처리) ...

        raise GeminiAllApiKeysExhaustedException("모든 API 키를 사용한 시도 후에도 텍스트 생성에 최종 실패했습니다.")

    def _rotate_api_key_and_reconfigure(self) -> bool:
        logger.debug("API 키 회전: 락 획득 대기 중...")
        with self._key_rotation_lock:
            # ... (키 목록 순회) ...
            for i in range(len(self.api_keys_list)):
                self.current_api_key_index = (original_index + 1 + i) % len(self.api_keys_list)
                next_key = self.api_keys_list[self.current_api_key_index]

                # ... (쿨다운 중인 키 건너뛰기) ...
                
                if next_key in self.client_pool:
                    self.current_api_key = next_key
                    self.client = self.client_pool[self.current_api_key]
                    return True
            # ... (회전 실패 처리) ...
</code></pre>


        </section>

        <!-- GUI 파일 (신규 섹션) -->
        <section id="gui-file">
            <h2 class="text-3xl font-bold text-gray-900 border-b pb-2 mb-6">GUI 소스 코드 (main_gui.py)</h2>
            <p class="text-gray-700 leading-relaxed mb-6">
                아래는 GUI 애플리케이션의 전체 소스 코드입니다.
            </p>
            
            <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-x-auto font-mono text-sm" data-filename="main_gui.py"><code># batch_translator_gui.py
import tkinter as tk
# from tkinter import ttk, filedialog, messagebox, scrolledtext, simpledialog # 기존 ttk 관련 import 주석 처리 또는 삭제
from tkinter import filedialog, messagebox, scrolledtext # 필요한 모듈만 남김
import ttkbootstrap as ttk # ttkbootstrap 임포트
from ttkbootstrap.constants import * # ttkbootstrap 상수 임포트
import threading
import os
from pathlib import Path
import sys # sys 모듈 임포트
import re

# 프로젝트 루트 디렉토리를 sys.path에 추가
project_root = Path(__file__).resolve().parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from typing import Optional, Dict, Any, List, Callable, Union
from dataclasses import dataclass
import json
import time
import io
import logging

# 4계층 아키텍처의 AppService 및 DTOs, Exceptions 임포트
try:
    from app.app_service import AppService
    from core.dtos import TranslationJobProgressDTO, GlossaryExtractionProgressDTO, ModelInfoDTO
    from core.exceptions import BtgConfigException, BtgServiceException, BtgFileHandlerException, BtgApiClientException, BtgBusinessLogicException, BtgException
    from infrastructure.logger_config import setup_logger
    from infrastructure.file_handler import get_metadata_file_path, load_metadata, _hash_config_for_metadata, delete_file
except ImportError as e:
    # Critical error: GUI cannot function without these core components.
    # Print to stderr and a simple dialog if tkinter is available enough for that.
    error_message = (
        f"초기 임포트 오류: {e}.\n"
        "스크립트가 프로젝트 루트에서 실행되고 있는지, "
        "PYTHONPATH가 올바르게 설정되었는지 확인하세요.\n"
        "필수 모듈을 임포트할 수 없어 GUI를 시작할 수 없습니다."
    )
    print(error_message, file=sys.stderr)
    try:
        # Attempt a simple messagebox if tkinter's core is loaded enough
        import tkinter as tk # Keep this import local to the except block
        from tkinter import messagebox # Keep this import local
        # Need to create a dummy root for messagebox if no root window exists yet
        dummy_root = tk.Tk()
        dummy_root.withdraw() # Hide the dummy root window
        messagebox.showerror("치명적 임포트 오류", error_message)
        dummy_root.destroy()
    except Exception:
        pass # If even this fails, the console message is the best we can do.
    sys.exit(1) # Exit if essential imports fail

GUI_LOGGER_NAME = __name__ + "_gui" # Define once for consistent use
logger = setup_logger(GUI_LOGGER_NAME) # Use the defined name
    
class Tooltip:
    """
    위젯 위에 마우스를 올렸을 때 툴팁을 표시하는 클래스입니다.
    wm_overrideredirect(True)를 사용하지 않아 macOS 호환성을 높입니다.
    """
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tooltip_window = None
        self.id = None # Timer ID for scheduling
        # Store mouse coordinates from <Enter> event
        self.enter_x_root = 0
        self.enter_y_root = 0
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.widget.bind("<ButtonPress>", self.leave) # 클릭 시에도 툴팁 숨김
    def enter(self, event=None):
        if event: # Store mouse position when entering the widget
            self.enter_x_root = event.x_root
            self.enter_y_root = event.y_root
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        # 툴팁 표시 전 약간의 지연 (0.5초)
        self.id = self.widget.after(500, self.showtip)

    def unschedule(self):
        id = self.id
        self.id = None
        if id:
            self.widget.after_cancel(id)

    def showtip(self, event=None): # 'event' here is from the 'after' call, not the original mouse event
        if not self.widget.winfo_exists():
            self.hidetip()
            return

        # 이전 툴팁 창이 있다면 파괴
        if self.tooltip_window:
            self.tooltip_window.destroy()
            self.tooltip_window = None
        
        # Create new tooltip window
        if not self.widget.winfo_exists(): # Double check, as time might have passed
            self.hidetip()
            return

        # Position the tooltip relative to the mouse cursor's position at <Enter>
        final_tooltip_x = self.enter_x_root + 15  # Offset from cursor
        final_tooltip_y = self.enter_y_root + 10  # Offset from cursor

        self.tooltip_window = tk.Toplevel(self.widget)
        self.tooltip_window.wm_overrideredirect(True) 
        self.tooltip_window.wm_geometry(f"+{int(final_tooltip_x)}+{int(final_tooltip_y)}")
        label = tk.Label(self.tooltip_window, text=self.text, justify='left',
                         background="#ffffe0", relief='solid', borderwidth=1,
                         font=("tahoma", "8", "normal"))
        label.pack(ipadx=1, ipady=1) # ipady 추가로 약간의 세로 여백

    def hidetip(self):
        tw = self.tooltip_window
        self.tooltip_window = None
        if tw:
            tw.destroy()


class TqdmToTkinter(io.StringIO):
    def __init__(self, widget: scrolledtext.ScrolledText):
        super().__init__()
        self.widget = widget
        self.widget.tag_config("TQDM", foreground="green")

    def write(self, buf):
        stripped_buf = buf.strip()
        if not stripped_buf:
            return

        def append_to_widget():
            if not self.widget.winfo_exists(): return
            
            timestamp = time.strftime('%H:%M:%S')
            log_message = f"{timestamp} - {stripped_buf}\n"
            
            current_state = self.widget.cget("state")
            self.widget.config(state=tk.NORMAL)
            self.widget.insert(tk.END, log_message, "TQDM")
            self.widget.config(state=current_state) 
            self.widget.see(tk.END)
            
        if self.widget.winfo_exists(): 
            self.widget.after(0, append_to_widget)

    def flush(self):
        pass

class ScrollableFrame:
    """스크롤 가능한 프레임을 생성하는 클래스"""
    
    def __init__(self, parent, height=None):
        # 메인 프레임 생성
        self.main_frame = ttk.Frame(parent)
        
        # Canvas와 Scrollbar 생성
        self.canvas = tk.Canvas(self.main_frame, highlightthickness=0)
        self.scrollbar = ttk.Scrollbar(self.main_frame, orient="vertical", command=self.canvas.yview)
        
        # 스크롤 가능한 내용을 담을 프레임
        self.scrollable_frame = ttk.Frame(self.canvas)
        
        # 스크롤바 설정
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
        # 프레임이 변경될 때마다 스크롤 영역 업데이트
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )
        
        # Canvas에 프레임 추가
        self.canvas_frame = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        
        # Canvas 크기 변경 시 내부 프레임 크기 조정
        self.canvas.bind("<Configure>", self._on_canvas_configure)
        
        # 마우스 휠 스크롤 바인딩
        self._bind_mouse_wheel()
        
        # 위젯 배치
        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")
        
        # 높이 설정 (선택사항)
        if height:
            self.canvas.configure(height=height)
    
    def _on_canvas_configure(self, event):
        """Canvas 크기 변경 시 내부 프레임 너비 조정"""
        self.canvas.itemconfig(self.canvas_frame, width=event.width)
    
    def _bind_mouse_wheel(self):
        """마우스 휠 스크롤 이벤트 바인딩"""
        def _on_mousewheel(event):
            self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        def _bind_to_mousewheel(event):
            self.canvas.bind_all("<MouseWheel>", _on_mousewheel)
        
        self.main_frame.bind('<Enter>', _bind_to_mousewheel)
    
    def pack(self, **kwargs):
        """메인 프레임 pack"""
        self.main_frame.pack(**kwargs)
    
    def grid(self, **kwargs):
        """메인 프레임 grid"""
        self.main_frame.grid(**kwargs)


class BatchTranslatorGUI:
    def __init__(self, master: tk.Tk):
        self.master = master
        master.title("BTG - 배치 번역기 (4-Tier Refactored)")
        master.geometry("950x800") 

        self.app_service: Optional[AppService] = None
        try:
            config_file = Path("config.json")
            self.app_service = AppService(config_file_path=config_file) 
            logger.info(f"AppService 인스턴스가 '{config_file}' 설정으로 생성되었습니다.")
        except BtgConfigException as e:
            logger.error(f"설정 파일 오류로 AppService 초기화 실패: {e}")
            messagebox.showerror("설정 오류", f"설정 파일 처리 중 오류가 발생했습니다: {e}\n기본 설정으로 시도합니다.")
            try:
                self.app_service = AppService() 
                logger.info("AppService가 기본 설정으로 초기화되었습니다.")
            except Exception as e_fallback:
                logger.critical(f"AppService 기본 설정 초기화마저 실패: {e_fallback}")
                messagebox.showerror("치명적 오류", f"애플리케이션 서비스 초기화에 실패했습니다: {e_fallback}")
                return 
        except Exception as e:
            logger.critical(f"AppService 초기화 중 예상치 못한 오류: {e}", exc_info=True)
            messagebox.showerror("초기화 오류", f"애플리케이션 서비스 초기화 중 심각한 오류 발생: {e}")
            return

        self.master.protocol("WM_DELETE_WINDOW", self._on_closing)
        self.glossary_stop_requested = False

        # ttkbootstrap 스타일 적용 (기존 ttk.Style() 부분 대체)
        # style = ttk.Style()
        # style.theme_use('clam')
        # style.configure("TButton", padding=6, relief="flat", background="#ddd")
        # style.map("TButton", background=[('active', '#ccc')])
        # style.configure("TNotebook.Tab", padding=[10, 5], font=('Helvetica', 10))
        # 위 부분을 아래 코드로 대체할 수 있으나, ttkbootstrap.Window가 자동으로 처리해줍니다.

        # 노트북 생성
        self.notebook = ttk.Notebook(master, bootstyle="primary") # bootstyle 적용
        
        # 스크롤 가능한 프레임들로 탭 생성
        self.settings_scroll = ScrollableFrame(self.notebook)
        self.glossary_scroll = ScrollableFrame(self.notebook) # Renamed from lorebook_scroll
        self.log_tab = ttk.Frame(self.notebook, padding="10")  # 로그 탭은 기존 유지
        
        # 탭 추가
        self.notebook.add(self.settings_scroll.main_frame, text='설정 및 번역')
        self.notebook.add(self.glossary_scroll.main_frame, text='용어집 관리') # Tab text changed
        
        self.notebook.add(self.log_tab, text='실행 로그')
        self.notebook.pack(expand=True, fill='both')
        
        # 위젯 생성 (스크롤 가능한 프레임 사용)
        self._create_settings_widgets()
        self._create_glossary_widgets() # Renamed from _create_lorebook_widgets
        
        self._create_log_widgets()

        if self.app_service:
            self._load_initial_config_to_ui() 
        else:
            self._log_message("AppService 초기화 실패로 UI에 설정을 로드할 수 없습니다.", "ERROR")

    def _request_stop_glossary_extraction(self):
        self.glossary_stop_requested = True
        self._log_message("용어집 추출 중지 요청됨.")

        

    def _load_initial_config_to_ui(self):
        if not self.app_service:
            logger.warning("AppService가 초기화되지 않았습니다.")
            return
        try:
            config = self.app_service.config 
            logger.info(f"초기 UI 로드 시작. AppService.config 사용: {json.dumps(config, indent=2, ensure_ascii=False)}")

            if hasattr(self, 'api_keys_text'): # Check if widget exists
                self.api_keys_text.config(state=tk.NORMAL)
                self.api_keys_text.delete('1.0', tk.END)
                api_keys_list = config.get("api_keys", [])
                logger.debug(f"Config에서 가져온 api_keys: {api_keys_list}")
                if api_keys_list:
                    self.api_keys_text.insert('1.0', "\n".join(api_keys_list))
            
            
            self.service_account_file_entry.delete(0, tk.END)
            sa_file_path = config.get("service_account_file_path")
            logger.debug(f"Config에서 가져온 service_account_file_path: {sa_file_path}")
            self.service_account_file_entry.insert(0, sa_file_path if sa_file_path is not None else "")

            use_vertex_ai_val = config.get("use_vertex_ai", False)
            logger.debug(f"Config에서 가져온 use_vertex_ai: {use_vertex_ai_val}")
            self.use_vertex_ai_var.set(use_vertex_ai_val) 
            
            self.gcp_project_entry.delete(0, tk.END)
            gcp_project_val = config.get("gcp_project")
            logger.debug(f"Config에서 가져온 gcp_project: {gcp_project_val}")
            self.gcp_project_entry.insert(0, gcp_project_val if gcp_project_val is not None else "")

            self.gcp_location_entry.delete(0, tk.END)
            gcp_location_val = config.get("gcp_location")
            logger.debug(f"Config에서 가져온 gcp_location: {gcp_location_val}")
            self.gcp_location_entry.insert(0, gcp_location_val if gcp_location_val is not None else "")

            self._toggle_vertex_fields() 
            
            model_name_from_config = config.get("model_name", "gemini-2.0-flash")
            logger.debug(f"Config에서 가져온 model_name: {model_name_from_config}")
            self.model_name_combobox.set(model_name_from_config) 
            self._update_model_list_ui() 

            temperature_val = config.get("temperature", 0.7)
            logger.debug(f"Config에서 가져온 temperature: {temperature_val}, 타입: {type(temperature_val)}")
            try:
                self.temperature_scale.set(float(temperature_val))
                self.temperature_label.config(text=f"{self.temperature_scale.get():.2f}") 
            except (ValueError, TypeError) as e:
                logger.warning(f"온도 값 설정 오류 ({temperature_val}): {e}. 기본값 사용.")
                default_temp = self.app_service.config_manager.get_default_config().get("temperature", 0.7)
                self.temperature_scale.set(default_temp)
                self.temperature_label.config(text=f"{default_temp:.2f}")


            top_p_val = config.get("top_p", 0.9)
            logger.debug(f"Config에서 가져온 top_p: {top_p_val}, 타입: {type(top_p_val)}")
            try:
                self.top_p_scale.set(float(top_p_val))
                self.top_p_label.config(text=f"{self.top_p_scale.get():.2f}") 
            except (ValueError, TypeError) as e:
                logger.warning(f"Top P 값 설정 오류 ({top_p_val}): {e}. 기본값 사용.")
                default_top_p = self.app_service.config_manager.get_default_config().get("top_p", 0.9)
                self.top_p_scale.set(default_top_p)
                self.top_p_label.config(text=f"{default_top_p:.2f}")

            thinking_budget_val = config.get("thinking_budget") # None일 수 있음
            logger.debug(f"Config에서 가져온 thinking_budget: {thinking_budget_val}")
            self.thinking_budget_entry.delete(0, tk.END)
            if thinking_budget_val is not None:
                self.thinking_budget_entry.insert(0, str(thinking_budget_val))
            else:
                self.thinking_budget_entry.insert(0, "") # 비어있으면 빈 문자열로 표시
            
            # Glossary Extraction User Override Prompt
            user_override_glossary_prompt_val = config.get("user_override_glossary_extraction_prompt", "")
            logger.debug(f"Config에서 가져온 user_override_glossary_extraction_prompt: {user_override_glossary_prompt_val[:50]}...")
            self.user_override_glossary_prompt_text.delete('1.0', tk.END)
            self.user_override_glossary_prompt_text.insert('1.0', user_override_glossary_prompt_val)


            chunk_size_val = config.get("chunk_size", 6000)
            logger.debug(f"Config에서 가져온 chunk_size: {chunk_size_val}")
            self.chunk_size_entry.delete(0, tk.END)
            self.chunk_size_entry.insert(0, str(chunk_size_val))
            
            max_workers_val = config.get("max_workers", os.cpu_count() or 1)
            logger.debug(f"Config에서 가져온 max_workers: {max_workers_val}")
            self.max_workers_entry.delete(0, tk.END)
            self.max_workers_entry.insert(0, str(max_workers_val))

            rpm_val = config.get("requests_per_minute", 60)
            logger.debug(f"Config에서 가져온 requests_per_minute: {rpm_val}")
            self.rpm_entry.delete(0, tk.END)
            self.rpm_entry.insert(0, str(rpm_val))

            # Language settings
            novel_lang_val = config.get("novel_language", "auto")
            self.novel_language_entry.delete(0, tk.END)
            self.novel_language_entry.insert(0, novel_lang_val)
            logger.debug(f"Config에서 가져온 novel_language: {novel_lang_val}")

            novel_lang_fallback_val = config.get("novel_language_fallback", "ja")
            self.novel_language_fallback_entry.delete(0, tk.END)
            self.novel_language_fallback_entry.insert(0, novel_lang_fallback_val)
            logger.debug(f"Config에서 가져온 novel_language_fallback: {novel_lang_fallback_val}")


            # Prefill settings
            self.enable_prefill_var.set(config.get("enable_prefill_translation", False))
            
            prefill_system_instruction_val = config.get("prefill_system_instruction", "")
            self.prefill_system_instruction_text.delete('1.0', tk.END)
            self.prefill_system_instruction_text.insert('1.0', prefill_system_instruction_val)

            prefill_cached_history_obj = config.get("prefill_cached_history", [])
            try:
                prefill_cached_history_json_str = json.dumps(prefill_cached_history_obj, indent=2, ensure_ascii=False)
            except TypeError:
                prefill_cached_history_json_str = "[]" # 기본값
            self.prefill_cached_history_text.delete('1.0', tk.END)
            self.prefill_cached_history_text.insert('1.0', prefill_cached_history_json_str)

            prompts_val = config.get("prompts", "") 
            logger.debug(f"Config에서 가져온 prompts: '{str(prompts_val)[:100]}...', 타입: {type(prompts_val)}")
            self.prompt_text.delete('1.0', tk.END)
            if isinstance(prompts_val, str):
                self.prompt_text.insert('1.0', prompts_val)
            elif isinstance(prompts_val, (list, tuple)) and prompts_val: 
                self.prompt_text.insert('1.0', str(prompts_val[0]))
            else: 
                default_prompt_config = self.app_service.config_manager.get_default_config().get("prompts", "")
                default_prompt_str = default_prompt_config[0] if isinstance(default_prompt_config, tuple) and default_prompt_config else str(default_prompt_config)
                self.prompt_text.insert('1.0', default_prompt_str)
                logger.warning(f"Prompts 타입이 예상과 다릅니다 ({type(prompts_val)}). 기본 프롬프트 사용.")
            
            # Lorebook specific settings
            glossary_json_path_val = config.get("glossary_json_path") # Key changed
            logger.debug(f"Config에서 가져온 glossary_json_path: {glossary_json_path_val}")
            self.glossary_json_path_entry.delete(0, tk.END) # Widget name changed
            self.glossary_json_path_entry.insert(0, glossary_json_path_val if glossary_json_path_val is not None else "")

            sample_ratio = config.get("glossary_sampling_ratio", 10.0) # Key changed, default to simpler
            self.sample_ratio_scale.set(sample_ratio)
            self.sample_ratio_label.config(text=f"{sample_ratio:.1f}%")
            
            # Removed UI elements for: max_entries_per_segment, sampling_method, max_chars_per_entry, keyword_sensitivity
            # These are not directly used by SimpleGlossaryService's prompt
            

            # For priority_settings, ai_prompt_template, conflict_resolution_prompt_template - ScrolledText
            # self.glossary_chunk_size_entry was removed, so no UI load needed.

            # Dynamic Lorebook Injection Settings
            self.enable_dynamic_glossary_injection_var.set(config.get("enable_dynamic_glossary_injection", False)) # Key changed, var name changed
            self.max_glossary_entries_injection_entry.delete(0, tk.END) # Widget name changed
            self.max_glossary_entries_injection_entry.insert(0, str(config.get("max_glossary_entries_per_chunk_injection", 3))) # Key changed
            self.max_glossary_chars_injection_entry.delete(0, tk.END) # Widget name changed
            self.max_glossary_chars_injection_entry.insert(0, str(config.get("max_glossary_chars_per_chunk_injection", 500))) # Key changed
            # lorebook_json_path_for_injection_entry 관련 UI 로드 코드는 제거 (아래 _create_settings_widgets 에서 해당 UI 요소 제거됨)

            extraction_temp = config.get("glossary_extraction_temperature", 0.3) # Key changed, default to simpler
            

            
            self.extraction_temp_scale.set(extraction_temp)
            self.extraction_temp_label.config(text=f"{extraction_temp:.2f}")

            # Content Safety Retry Settings
            use_content_safety_retry_val = config.get("use_content_safety_retry", True)
            self.use_content_safety_retry_var.set(use_content_safety_retry_val)

            max_split_attempts_val = config.get("max_content_safety_split_attempts", 3)
            self.max_split_attempts_entry.delete(0, tk.END)
            self.max_split_attempts_entry.insert(0, str(max_split_attempts_val))

            min_chunk_size_val = config.get("min_content_safety_chunk_size", 100)
            self.min_chunk_size_entry.delete(0, tk.END)
            self.min_chunk_size_entry.insert(0, str(min_chunk_size_val))
            logger.info("UI에 설정 로드 완료.")
        except BtgConfigException as e: 
            messagebox.showerror("설정 로드 오류", f"설정 로드 중 오류: {e}")
            self._log_message(f"설정 로드 오류: {e}", "ERROR")
        except Exception as e:
            messagebox.showerror("오류", f"설정 UI 반영 중 예상치 못한 오류: {e}")
            self._log_message(f"설정 UI 반영 중 오류: {e}", "ERROR", exc_info=True)


    def _create_settings_widgets(self):
        # 스크롤 가능한 프레임의 내부 프레임 사용
        settings_frame = self.settings_scroll.scrollable_frame   

        # API 및 인증 설정
        api_frame = ttk.Labelframe(settings_frame, text="API 및 인증 설정", padding="10")
        api_frame.pack(fill="x", padx=5, pady=5)
        
        self.api_keys_label = ttk.Label(api_frame, text="API 키 목록 (Gemini Developer, 한 줄에 하나씩):")
        self.api_keys_label.grid(row=0, column=0, padx=5, pady=5, sticky="nw")
        Tooltip(self.api_keys_label, "Gemini Developer API를 사용할 경우 API 키를 입력합니다.\n여러 개일 경우 한 줄에 하나씩 입력하세요.")
        
        self.api_keys_text = scrolledtext.ScrolledText(api_frame, width=58, height=3, wrap=tk.WORD)
        self.api_keys_text.grid(row=0, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
        # API 키 텍스트가 변경될 때마다 이벤트 핸들러 연결
        Tooltip(self.api_keys_text, "사용할 Gemini API 키 목록입니다.")
        self.api_keys_text.bind('<KeyRelease>', self._on_api_key_changed)

        
        # Vertex AI 설정
        self.use_vertex_ai_var = tk.BooleanVar()
        self.use_vertex_ai_check = ttk.Checkbutton(api_frame, text="Vertex AI 사용", 
                                                   variable=self.use_vertex_ai_var, 
                                                   command=self._toggle_vertex_fields)
        self.use_vertex_ai_check.grid(row=1, column=0, columnspan=3, padx=5, pady=2, sticky="w")
        Tooltip(self.use_vertex_ai_check, "Google Cloud Vertex AI API를 사용하려면 선택하세요.\n서비스 계정 JSON 파일 또는 ADC 인증이 필요합니다.")

        self.service_account_file_label = ttk.Label(api_frame, text="서비스 계정 JSON 파일 (Vertex AI):")
        self.service_account_file_label.grid(row=2, column=0, padx=5, pady=5, sticky="w")
        Tooltip(self.service_account_file_label, "Vertex AI 인증에 사용할 서비스 계정 JSON 파일의 경로입니다.")
        self.service_account_file_entry = ttk.Entry(api_frame, width=50)
        self.service_account_file_entry.grid(row=2, column=1, padx=5, pady=5, sticky="ew")
        Tooltip(self.service_account_file_entry, "Vertex AI 서비스 계정 파일 경로를 입력하거나 '찾아보기'로 선택하세요.")
        self.browse_sa_file_button = ttk.Button(api_frame, text="찾아보기", command=self._browse_service_account_file)
        self.browse_sa_file_button.grid(row=2, column=2, padx=5, pady=5)
        Tooltip(self.browse_sa_file_button, "서비스 계정 JSON 파일을 찾습니다.")

        self.gcp_project_label = ttk.Label(api_frame, text="GCP 프로젝트 ID (Vertex AI):")
        self.gcp_project_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
        Tooltip(self.gcp_project_label, "Vertex AI 사용 시 필요한 Google Cloud Project ID입니다.")
        self.gcp_project_entry = ttk.Entry(api_frame, width=30)
        self.gcp_project_entry.grid(row=3, column=1, padx=5, pady=5, sticky="ew")
        Tooltip(self.gcp_project_entry, "GCP 프로젝트 ID를 입력하세요.")

        self.gcp_location_label = ttk.Label(api_frame, text="GCP 위치 (Vertex AI):")
        self.gcp_location_label.grid(row=4, column=0, padx=5, pady=5, sticky="w")
        Tooltip(self.gcp_location_label, "Vertex AI 모델이 배포된 GCP 리전입니다 (예: asia-northeast3).")
        self.gcp_location_entry = ttk.Entry(api_frame, width=30)
        self.gcp_location_entry.grid(row=4, column=1, padx=5, pady=5, sticky="ew")
        Tooltip(self.gcp_location_entry, "GCP 리전을 입력하세요.")

        model_name_label = ttk.Label(api_frame, text="모델 이름:")
        model_name_label.grid(row=5, column=0, padx=5, pady=5, sticky="w")
        Tooltip(model_name_label, "번역에 사용할 AI 모델의 이름입니다.")
        self.model_name_combobox = ttk.Combobox(api_frame, width=57) 
        self.model_name_combobox.grid(row=5, column=1, padx=5, pady=5, sticky="ew")
        Tooltip(self.model_name_combobox, "사용 가능한 모델 목록에서 선택하거나 직접 입력하세요.\n'새로고침' 버튼으로 목록을 업데이트할 수 있습니다.")
        self.refresh_models_button = ttk.Button(api_frame, text="새로고침", command=self._update_model_list_ui)
        self.refresh_models_button.grid(row=5, column=2, padx=5, pady=5)
        Tooltip(self.refresh_models_button, "사용 가능한 모델 목록을 API에서 새로 가져옵니다.")

        # 생성 파라미터
        gen_param_frame = ttk.Labelframe(settings_frame, text="생성 파라미터", padding="10")
        gen_param_frame.pack(fill="x", padx=5, pady=5)
        
        # Temperature 설정
        temperature_param_label = ttk.Label(gen_param_frame, text="Temperature:")
        temperature_param_label.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        Tooltip(temperature_param_label, "모델 응답의 무작위성 조절 (낮을수록 결정적, 높을수록 다양).")
        self.temperature_scale = ttk.Scale(gen_param_frame, from_=0.0, to=2.0, orient="horizontal", length=200,
                                         command=lambda v: self.temperature_label.config(text=f"{float(v):.2f}"))
        self.temperature_scale.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        Tooltip(self.temperature_scale, "Temperature 값을 조절합니다 (0.0 ~ 2.0).")
        self.temperature_label = ttk.Label(gen_param_frame, text="0.00")
        self.temperature_label.grid(row=0, column=2, padx=5, pady=5)
        
        # Top P 설정
        top_p_param_label = ttk.Label(gen_param_frame, text="Top P:")
        top_p_param_label.grid(row=1, column=0, padx=5, pady=5, sticky="w")
        Tooltip(top_p_param_label, "모델이 다음 단어를 선택할 때 고려하는 확률 분포의 누적합 (낮을수록 집중적, 높을수록 다양).")
        self.top_p_scale = ttk.Scale(gen_param_frame, from_=0.0, to=1.0, orient="horizontal", length=200,
                                   command=lambda v: self.top_p_label.config(text=f"{float(v):.2f}"))
        self.top_p_scale.grid(row=1, column=1, padx=5, pady=5, sticky="ew")
        Tooltip(self.top_p_scale, "Top P 값을 조절합니다 (0.0 ~ 1.0).")
        self.top_p_label = ttk.Label(gen_param_frame, text="0.00")
        self.top_p_label.grid(row=1, column=2, padx=5, pady=5)

        # Thinking Budget 설정
        thinking_budget_param_label = ttk.Label(gen_param_frame, text="Thinking Budget:")
        thinking_budget_param_label.grid(row=2, column=0, padx=5, pady=5, sticky="w")
        Tooltip(thinking_budget_param_label, "모델이 추론에 사용할 토큰 수 (Gemini 2.5 모델).\nFlash: 0-24576, Pro: 128-32768.\n비워두면 자동 또는 모델 기본값 사용.")
        self.thinking_budget_entry = ttk.Entry(gen_param_frame, width=10)
        self.thinking_budget_entry.grid(row=2, column=1, padx=5, pady=5, sticky="w")
        Tooltip(self.thinking_budget_entry, "Thinking Budget 값을 정수로 입력하세요.\nFlash 모델에서 0은 기능 비활성화입니다.\n비워두는것을 추천함")
        

        
        # 파일 및 처리 설정
        file_chunk_frame = ttk.Labelframe(settings_frame, text="파일 및 처리 설정", padding="10")
        file_chunk_frame.pack(fill="x", padx=5, pady=5)
        
        # 입력 파일 섹션 수정
        input_file_frame = ttk.Labelframe(file_chunk_frame, text="입력 파일 목록", padding="5")
        input_file_frame.grid(row=0, column=0, columnspan=3, sticky="ew", padx=5, pady=5)

        self.input_file_listbox = tk.Listbox(input_file_frame, selectmode=tk.EXTENDED, width=70, height=5)
        self.input_file_listbox.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        
        listbox_scrollbar = ttk.Scrollbar(input_file_frame, orient="vertical", command=self.input_file_listbox.yview)
        listbox_scrollbar.pack(side="right", fill="y")
        self.input_file_listbox.config(yscrollcommand=listbox_scrollbar.set)

        # 파일 추가/삭제 버튼 프레임
        file_button_frame = ttk.Frame(input_file_frame)
        file_button_frame.pack(side="left", fill="y", padx=5)

        self.add_files_button = ttk.Button(file_button_frame, text="파일 추가", command=self._browse_input_files)
        self.add_files_button.pack(pady=2, fill="x")
        Tooltip(self.add_files_button, "번역할 파일을 목록에 추가합니다.")
        
        self.remove_file_button = ttk.Button(file_button_frame, text="선택 삭제", command=self._remove_selected_files)
        self.remove_file_button.pack(pady=2, fill="x")
        Tooltip(self.remove_file_button, "목록에서 선택한 파일을 제거합니다.")

        # 출력 파일
        output_file_label_widget = ttk.Label(file_chunk_frame, text="출력 파일 (단일 모드):")
        output_file_label_widget.grid(row=1, column=0, padx=5, pady=5, sticky="w")
        Tooltip(output_file_label_widget, "단일 파일 번역 시 사용될 출력 파일 경로입니다.\n(배치 처리 시에는 각 파일별로 자동 생성됩니다)")
        self.output_file_entry = ttk.Entry(file_chunk_frame, width=50)
        self.output_file_entry.grid(row=1, column=1, padx=5, pady=5, sticky="ew")
        Tooltip(self.output_file_entry, "번역 결과를 저장할 파일 경로를 입력하거나 '찾아보기'로 선택하세요.")
        self.browse_output_button = ttk.Button(file_chunk_frame, text="찾아보기", command=self._browse_output_file)
        self.browse_output_button.grid(row=1, column=2, padx=5, pady=5)
        Tooltip(self.browse_output_button, "번역 결과를 저장할 출력 파일을 선택합니다.")
        
        # 청크 크기 및 작업자 수
        chunk_worker_frame = ttk.Frame(file_chunk_frame)
        chunk_worker_frame.grid(row=2, column=0, columnspan=3, sticky="ew", pady=5)
        
        chunk_size_label_widget = ttk.Label(chunk_worker_frame, text="청크 크기:")
        chunk_size_label_widget.pack(side="left", padx=(0,5))
        Tooltip(chunk_size_label_widget, "API 요청당 처리할 텍스트의 최대 문자 수입니다.")      
        self.chunk_size_entry = ttk.Entry(chunk_worker_frame, width=10)
        self.chunk_size_entry.pack(side="left", padx=(0,15))
        Tooltip(self.chunk_size_entry, "청크 크기를 입력하세요 (예: 6000).")
        
        max_workers_label_widget = ttk.Label(chunk_worker_frame, text="최대 작업자 수:")
        max_workers_label_widget.pack(side="left", padx=(10,5))
        Tooltip(max_workers_label_widget, "동시에 실행할 번역 스레드의 최대 개수입니다.")       
        self.max_workers_entry = ttk.Entry(chunk_worker_frame, width=5)
        self.max_workers_entry.pack(side="left")
        self.max_workers_entry.insert(0, str(os.cpu_count() or 1))
        Tooltip(self.max_workers_entry, "최대 작업자 수를 입력하세요 (예: 4).")
        
        # RPM 설정
        rpm_label_widget = ttk.Label(chunk_worker_frame, text="분당 요청 수 (RPM):")
        rpm_label_widget.pack(side="left", padx=(10,5))
        Tooltip(rpm_label_widget, "API에 분당 보낼 수 있는 최대 요청 수입니다. 0은 제한 없음을 의미합니다.")
        
        self.rpm_entry = ttk.Entry(chunk_worker_frame, width=5)
        self.rpm_entry.pack(side="left")
        Tooltip(self.rpm_entry, "분당 요청 수를 입력하세요 (예: 60).")

        # Language Settings Frame
        language_settings_frame = ttk.Labelframe(settings_frame, text="언어 설정", padding="10")
        language_settings_frame.pack(fill="x", padx=5, pady=5)

        novel_lang_label = ttk.Label(language_settings_frame, text="소설/번역 출발 언어:")
        novel_lang_label.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        Tooltip(novel_lang_label, "번역할 원본 텍스트의 언어 코드입니다 (예: ko, ja, en).\n'auto'로 설정 시 언어를 자동으로 감지합니다.")
        self.novel_language_entry = ttk.Entry(language_settings_frame, width=10)
        self.novel_language_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")
        self.novel_language_entry.insert(0, "auto") 
        Tooltip(self.novel_language_entry, "언어 코드를 입력하세요 (BCP-47 형식).")
        ttk.Label(language_settings_frame, text="(예: ko, ja, en, auto)").grid(row=0, column=2, padx=5, pady=5, sticky="w")

        novel_lang_fallback_label = ttk.Label(language_settings_frame, text="언어 자동감지 실패 시 폴백:")
        novel_lang_fallback_label.grid(row=1, column=0, padx=5, pady=5, sticky="w")
        Tooltip(novel_lang_fallback_label, "출발 언어 자동 감지 실패 시 사용할 기본 언어 코드입니다.")
        self.novel_language_fallback_entry = ttk.Entry(language_settings_frame, width=10)
        self.novel_language_fallback_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")
        self.novel_language_fallback_entry.insert(0, "ja")
        Tooltip(self.novel_language_fallback_entry, "폴백 언어 코드를 입력하세요.")
        ttk.Label(language_settings_frame, text="(예: ko, ja, en)").grid(row=1, column=2, padx=5, pady=5, sticky="w")

        # 시스템 지침 및 번역 프롬프트 프레임
        prompt_frame = ttk.Labelframe(settings_frame, text="프롬프트 설정", padding="10")
        prompt_frame.pack(fill="both", expand=True, padx=5, pady=5)
        # 일반 시스템 지침 UI 제거

        # 번역 프롬프트 (기존 Chat Prompt 역할)
        chat_prompt_label = ttk.Label(prompt_frame, text="번역 프롬프트 (Chat/User Prompt):")
        chat_prompt_label.pack(anchor="w", padx=5, pady=(10,0))
        Tooltip(prompt_frame, "번역 모델에 전달할 프롬프트입니다.\n{{slot}}은 번역할 텍스트 청크로 대체됩니다.\n{{glossary_context}}는 용어집 내용으로 대체됩니다.")
        self.prompt_text = scrolledtext.ScrolledText(prompt_frame, wrap=tk.WORD, height=10, width=70) # 기본 높이 조정
        self.prompt_text.pack(fill="both", expand=True, padx=5, pady=5)
        
        # 프리필 번역 설정 프레임
        prefill_frame = ttk.Labelframe(settings_frame, text="프리필(Prefill) 번역 설정", padding="10")
        prefill_frame.pack(fill="both", expand=True, padx=5, pady=5)
        Tooltip(prefill_frame, "모델에 초기 컨텍스트(시스템 지침 및 대화 기록)를 제공하여 번역 품질을 향상시킬 수 있습니다.")

        self.enable_prefill_var = tk.BooleanVar()
        self.enable_prefill_check = ttk.Checkbutton(prefill_frame, text="프리필 번역 사용", variable=self.enable_prefill_var)
        self.enable_prefill_check.pack(anchor="w", padx=5, pady=(5,0))
        Tooltip(self.enable_prefill_check, "활성화 시 아래의 프리필 시스템 지침과 캐시된 히스토리를 사용합니다.")

        prefill_system_instruction_label = ttk.Label(prefill_frame, text="프리필 시스템 지침:")
        prefill_system_instruction_label.pack(anchor="w", padx=5, pady=(5,0))
        Tooltip(prefill_system_instruction_label, "프리필 모드에서 사용할 시스템 레벨 지침입니다.")
        self.prefill_system_instruction_text = scrolledtext.ScrolledText(prefill_frame, wrap=tk.WORD, height=10, width=70) # 기본 높이 조정
        self.prefill_system_instruction_text.pack(fill="both", expand=True, padx=5, pady=5)

        prefill_cached_history_label = ttk.Label(prefill_frame, text="프리필 캐시된 히스토리 (JSON 형식):")
        prefill_cached_history_label.pack(anchor="w", padx=5, pady=(5,0))
        Tooltip(prefill_cached_history_label, "미리 정의된 대화 기록을 JSON 형식으로 입력합니다.\n예: [{\"role\": \"user\", \"parts\": [\"안녕\"]}, {\"role\": \"model\", \"parts\": [\"안녕하세요.\"]}]")
        self.prefill_cached_history_text = scrolledtext.ScrolledText(prefill_frame, wrap=tk.WORD, height=10, width=70) # 기본 높이 조정
        self.prefill_cached_history_text.pack(fill="both", expand=True, padx=5, pady=5)        # 콘텐츠 안전 재시도 설정
        content_safety_frame = ttk.Labelframe(settings_frame, text="콘텐츠 안전 재시도 설정", padding="10")
        content_safety_frame.pack(fill="x", padx=5, pady=5)

        self.use_content_safety_retry_var = tk.BooleanVar()
        self.use_content_safety_retry_check = ttk.Checkbutton(
            content_safety_frame,
            text="검열 오류시 청크 분할 재시도 사용",
            variable=self.use_content_safety_retry_var
        )
        Tooltip(self.use_content_safety_retry_check, "API에서 콘텐츠 안전 문제로 응답이 차단될 경우,\n텍스트를 더 작은 조각으로 나누어 재시도합니다.")
        self.use_content_safety_retry_check.grid(row=0, column=0, columnspan=3, padx=5, pady=2, sticky="w")
        
        max_split_label = ttk.Label(content_safety_frame, text="최대 분할 시도:")
        max_split_label.grid(row=1, column=0, padx=5, pady=5, sticky="w")
        Tooltip(max_split_label, "콘텐츠 안전 문제 발생 시 청크를 나누어 재시도할 최대 횟수입니다.")
        self.max_split_attempts_entry = ttk.Entry(content_safety_frame, width=5)
        self.max_split_attempts_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")
        self.max_split_attempts_entry.insert(0, "3")
        Tooltip(self.max_split_attempts_entry, "최대 분할 시도 횟수를 입력하세요.")
        
        min_chunk_label = ttk.Label(content_safety_frame, text="최소 청크 크기:")
        min_chunk_label.grid(row=2, column=0, padx=5, pady=5, sticky="w")
        Tooltip(min_chunk_label, "분할 재시도 시 청크가 이 크기보다 작아지지 않도록 합니다.")
        self.min_chunk_size_entry = ttk.Entry(content_safety_frame, width=10)
        self.min_chunk_size_entry.grid(row=2, column=1, padx=5, pady=5, sticky="w")
        self.min_chunk_size_entry.insert(0, "100")
        Tooltip(self.min_chunk_size_entry, "최소 청크 크기를 입력하세요.")

        

        # 주입용 로어북 JSON 경로 입력 필드는 "로어북 관리" 탭의 경로를 사용하므로 여기서는 제거합니다.
        # 액션 버튼들
        action_frame = ttk.Frame(settings_frame, padding="10")
        action_frame.pack(fill="x", padx=5, pady=5)
        
        self.save_settings_button = ttk.Button(action_frame, text="설정 저장", command=self._save_settings)
        self.save_settings_button.pack(side="left", padx=5)
        Tooltip(self.save_settings_button, "현재 UI에 입력된 모든 설정을 config.json 파일에 저장합니다.")
        
        self.load_settings_button = ttk.Button(action_frame, text="설정 불러오기", command=self._load_settings_ui)
        self.load_settings_button.pack(side="left", padx=5)
        Tooltip(self.load_settings_button, "config.json 파일에서 설정을 불러와 UI에 적용합니다.")
        
        self.start_button = ttk.Button(action_frame, text="번역 시작", command=self._start_translation_thread_with_resume_check)
        self.start_button.pack(side="right", padx=5)
        Tooltip(self.start_button, "현재 설정으로 입력 파일의 번역 작업을 시작합니다.")

        self.retry_failed_button = ttk.Button(action_frame, text="실패 청크 재시도", command=self._start_failed_chunks_translation_thread)
        self.retry_failed_button.pack(side="right", padx=5)
        Tooltip(self.retry_failed_button, "선택한 파일의 메타데이터에 기록된 실패한 청크들만 다시 번역합니다.")
        
        self.stop_button = ttk.Button(action_frame, text="중지", command=self._request_stop_translation, state=tk.DISABLED)
        self.stop_button.pack(side="right", padx=5)
        Tooltip(self.stop_button, "현재 진행 중인 번역 작업을 중지 요청합니다.")
        
        # 진행률 표시
        progress_frame = ttk.Frame(settings_frame)
        progress_frame.pack(fill="x", padx=15, pady=10)
        
        self.progress_bar = ttk.Progressbar(progress_frame, orient="horizontal", length=300, mode="determinate")
        self.progress_bar.pack(fill="x", pady=5)
        Tooltip(self.progress_bar, "번역 작업의 전체 진행률을 표시합니다.")
        
        self.progress_label = ttk.Label(progress_frame, text="대기 중...")
        self.progress_label.pack(pady=2)
        Tooltip(self.progress_label, "번역 작업의 현재 상태 및 진행 상황을 텍스트로 표시합니다.")


    def _browse_service_account_file(self):
        filepath = filedialog.askopenfilename(
            title="서비스 계정 JSON 파일 선택",
            filetypes=(("JSON 파일", "*.json"), ("모든 파일", "*.*"))
        )
        if filepath:
            self.service_account_file_entry.delete(0, tk.END)
            self.service_account_file_entry.insert(0, filepath)

    def _toggle_vertex_fields(self):
        use_vertex = self.use_vertex_ai_var.get()
        logger.debug(f"_toggle_vertex_fields 호출됨. use_vertex_ai_var: {use_vertex}")
        api_related_state = tk.DISABLED if use_vertex else tk.NORMAL
        vertex_related_state = tk.NORMAL if use_vertex else tk.DISABLED

        if hasattr(self, 'api_keys_label'): self.api_keys_label.config(state=api_related_state)
        if hasattr(self, 'api_keys_text'): self.api_keys_text.config(state=api_related_state)
        
        if hasattr(self, 'service_account_file_label'): self.service_account_file_label.config(state=vertex_related_state)
        if hasattr(self, 'service_account_file_entry'): self.service_account_file_entry.config(state=vertex_related_state)
        if hasattr(self, 'browse_sa_file_button'): self.browse_sa_file_button.config(state=vertex_related_state)
        if hasattr(self, 'gcp_project_label'): self.gcp_project_label.config(state=vertex_related_state)
        if hasattr(self, 'gcp_project_entry'): self.gcp_project_entry.config(state=vertex_related_state)
        if hasattr(self, 'gcp_location_label'): self.gcp_location_label.config(state=vertex_related_state)
        if hasattr(self, 'gcp_location_entry'): self.gcp_location_entry.config(state=vertex_related_state)
        logger.debug(f"Vertex 필드 상태: {vertex_related_state}, API 키 필드 상태: {api_related_state}")


    def _create_glossary_widgets(self): # Renamed from _create_lorebook_widgets
        # 스크롤 가능한 프레임의 내부 프레임 사용
        glossary_frame = self.glossary_scroll.scrollable_frame # Renamed

        
        # 로어북 JSON 파일 설정
        path_frame = ttk.Labelframe(glossary_frame, text="용어집 JSON 파일", padding="10") # Text changed
        
        path_frame.pack(fill="x", padx=5, pady=5)
        
        glossary_json_path_label = ttk.Label(path_frame, text="JSON 파일 경로:") # Text changed
        glossary_json_path_label.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        Tooltip(glossary_json_path_label, "사용할 용어집 JSON 파일의 경로입니다.\n추출 기능을 사용하면 자동으로 채워지거나, 직접 입력/선택할 수 있습니다.")     
        self.glossary_json_path_entry = ttk.Entry(path_frame, width=50) # Renamed
        self.glossary_json_path_entry.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        self.browse_glossary_json_button = ttk.Button(path_frame, text="찾아보기", command=self._browse_glossary_json) # Renamed
        self.browse_glossary_json_button.grid(row=0, column=2, padx=5, pady=5)
        

        glossary_action_button_frame = ttk.Frame(path_frame)
        glossary_action_button_frame.grid(row=2, column=0, columnspan=3, pady=10)

        self.extract_glossary_button = ttk.Button(glossary_action_button_frame, text="선택한 입력 파일에서 용어집 추출", command=self._extract_glossary_thread)
        self.extract_glossary_button.pack(side="left", padx=5)
        Tooltip(self.extract_glossary_button, "'설정 및 번역' 탭에서 선택된 입력 파일을 분석하여 용어집을 추출하고, 그 결과를 아래 텍스트 영역에 표시합니다.")

        self.stop_glossary_button = ttk.Button(glossary_action_button_frame, text="추출 중지", command=self._request_stop_glossary_extraction, state=tk.DISABLED)
        self.stop_glossary_button.pack(side="left", padx=5)
        Tooltip(self.stop_glossary_button, "진행 중인 용어집 추출 작업을 중지하고 현재까지의 결과로 저장합니다.")
        
        self.glossary_progress_label = ttk.Label(path_frame, text="용어집 추출 대기 중...") # Renamed
        self.glossary_progress_label.grid(row=3, column=0, columnspan=3, padx=5, pady=2)
        Tooltip(self.glossary_progress_label, "용어집 추출 작업의 진행 상태를 표시합니다.") # Text changed


        # 용어집 추출 설정 프레임 (경량화)
        extraction_settings_frame = ttk.Labelframe(glossary_frame, text="용어집 추출 설정", padding="10") # Text changed
        
        extraction_settings_frame.pack(fill="x", padx=5, pady=5)
        
        # 샘플링 비율 설정 (lorebook_sampling_ratio)
        sample_ratio_label_widget = ttk.Label(extraction_settings_frame, text="샘플링 비율 (%):")
        sample_ratio_label_widget.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        Tooltip(sample_ratio_label_widget, "용어집 추출 시 전체 텍스트 중 분석할 비율입니다.\n100%로 설정하면 전체 텍스트를 분석합니다.") # Text changed
        sample_ratio_frame = ttk.Frame(extraction_settings_frame)
        sample_ratio_frame.grid(row=0, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
        
        self.sample_ratio_scale = ttk.Scale(
            sample_ratio_frame, 
            from_=5.0, 
            to=100.0, 
            orient="horizontal", 
            length=200,
            command=self._update_sample_ratio_label
        )
        self.sample_ratio_scale.pack(side="left", padx=(0,10))
        Tooltip(self.sample_ratio_scale, "용어집 추출 샘플링 비율을 조절합니다 (5.0% ~ 100.0%).") # Text changed
        

        self.sample_ratio_label = ttk.Label(sample_ratio_frame, text="25.0%", width=8)
        self.sample_ratio_label.pack(side="left")
        Tooltip(self.sample_ratio_label, "현재 설정된 샘플링 비율입니다.")
        

        
        # 제거된 UI 요소들:
        # - 세그먼트 당 최대 항목 수 (max_entries_per_segment_spinbox, max_entries_per_segment_label)
        # - 샘플링 방식 (glossary_sampling_method_combobox)
        # - 항목 당 최대 글자 수 (glossary_max_chars_entry)
        # - 키워드 민감도 (glossary_keyword_sensitivity_combobox)
        # - 용어집 세그먼트 크기 (glossary_chunk_size_entry)
        # - 우선순위 설정 (glossary_priority_text)
        # 이들은 SimpleGlossaryService에서 직접 사용하지 않으므로 UI에서 제거.
        

        
        # 고급 설정 (접을 수 있는 형태)
        self.advanced_var = tk.BooleanVar()
        advanced_check = ttk.Checkbutton(
            extraction_settings_frame, 
            text="고급 설정 표시", 
            variable=self.advanced_var,
            command=self._toggle_advanced_settings
        )
        Tooltip(advanced_check, "용어집 추출에 사용될 추출 온도 설정을 표시하거나 숨깁니다.") # Text changed              
        advanced_check.grid(row=4, column=0, columnspan=3, padx=5, pady=(15,5), sticky="w")
        
        # 고급 설정 프레임 (초기에는 숨김)
        self.advanced_frame = ttk.Frame(extraction_settings_frame)
        self.advanced_frame.grid(row=5, column=0, columnspan=3, padx=5, pady=5, sticky="ew")
        
        # 온도 설정 (용어집 추출용)        
        extraction_temp_label_widget = ttk.Label(self.advanced_frame, text="추출 온도:")
        extraction_temp_label_widget.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        Tooltip(extraction_temp_label_widget, "용어집 추출 시 모델 응답의 무작위성입니다.\n낮을수록 일관적, 높을수록 다양하지만 덜 정확할 수 있습니다.") # Text changed       
        self.extraction_temp_scale = ttk.Scale(
            self.advanced_frame,
            from_=0.0,
            to=1.0,
            orient="horizontal",
            length=150,
            command=self._update_extraction_temp_label
        )
        self.extraction_temp_scale.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        Tooltip(self.extraction_temp_scale, "용어집 추출 온도를 조절합니다 (0.0 ~ 1.0).") # Text changed
        
        self.extraction_temp_scale.set(0.3)  # 경량화된 서비스 기본값               
        self.extraction_temp_label = ttk.Label(self.advanced_frame, text="0.20", width=6)
        self.extraction_temp_label.grid(row=0, column=2, padx=5, pady=5)
        Tooltip(self.extraction_temp_label, "현재 설정된 용어집 추출 온도입니다.") # Text changed

        # 사용자 재정의 용어집 추출 프롬프트
        user_override_glossary_prompt_label = ttk.Label(self.advanced_frame, text="사용자 재정의 추출 프롬프트:")
        user_override_glossary_prompt_label.grid(row=1, column=0, padx=5, pady=5, sticky="nw")
        Tooltip(user_override_glossary_prompt_label, "용어집 추출 시 사용할 사용자 정의 프롬프트입니다.\n비워두면 기본 프롬프트를 사용합니다.\n플레이스홀더: {target_lang_name}, {target_lang_code}, {novelText}")
        
        self.user_override_glossary_prompt_text = scrolledtext.ScrolledText(self.advanced_frame, wrap=tk.WORD, height=8, width=60)
        self.user_override_glossary_prompt_text.grid(row=1, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
        Tooltip(self.user_override_glossary_prompt_text, "사용자 정의 프롬프트를 입력하세요. JSON 응답 형식을 유지해야 합니다.")


        

        
        # 초기에는 고급 설정 숨김
        self.advanced_frame.grid_remove()

        # 액션 버튼 프레임 추가
        glossary_action_frame = ttk.Frame(glossary_frame, padding="10") # Renamed
        glossary_action_frame.pack(fill="x", padx=5, pady=5)
        

        # 설정 저장 버튼
        self.save_glossary_settings_button = ttk.Button( # Renamed
            glossary_action_frame,
            text="용어집 설정 저장", # Text changed
            command=self._save_glossary_settings # Command changed
        )
        Tooltip(self.save_glossary_settings_button, "현재 용어집 탭의 설정을 config.json 파일에 저장합니다.") # Text changed
        self.save_glossary_settings_button.pack(side="left", padx=5)
        

        # 설정 초기화 버튼
        self.reset_glossary_settings_button = ttk.Button( # Renamed
            glossary_action_frame, 
            text="기본값으로 초기화", 
            command=self._reset_glossary_settings # Command changed
        )
        Tooltip(self.reset_glossary_settings_button, "용어집 탭의 모든 설정을 프로그램 기본값으로 되돌립니다.") # Text changed
        self.reset_glossary_settings_button.pack(side="left", padx=5)
        

        
        # 실시간 미리보기 버튼
        self.preview_glossary_settings_button = ttk.Button( # Renamed
            glossary_action_frame,
            text="설정 미리보기", 
            command=self._preview_glossary_settings # Command changed
        )
        Tooltip(self.preview_glossary_settings_button, "현재 용어집 설정이 실제 추출에 미칠 영향을 간략하게 미리봅니다.") # Text changed
        self.preview_glossary_settings_button.pack(side="right", padx=5)



        # 상태 표시 레이블
        self.glossary_status_label = ttk.Label( # Renamed
            glossary_action_frame,

            font=("Arial", 9),
            foreground="gray"
        )
        Tooltip(self.glossary_status_label, "용어집 설정 변경 및 저장 상태를 표시합니다.") # Text changed
        self.glossary_status_label.pack(side="bottom", pady=5)



        

        # Lorebook Display Area
        glossary_display_frame = ttk.Labelframe(glossary_frame, text="추출된 용어집 (JSON)", padding="10") # Text changed
        glossary_display_frame.pack(fill="both", expand=True, padx=5, pady=5)
        Tooltip(glossary_display_frame, "추출되거나 불러온 용어집의 내용이 JSON 형식으로 표시됩니다.") # Text changed

        self.glossary_display_text = scrolledtext.ScrolledText(glossary_display_frame, wrap=tk.WORD, height=10, width=70) # Widget name changed
        self.glossary_display_text.pack(fill="both", expand=True, padx=5, pady=5)
        Tooltip(self.glossary_display_text, "용어집 내용입니다. 직접 편집은 불가능하며, 'JSON 저장'으로 파일 저장 후 수정할 수 있습니다.") # Text changed

        glossary_display_buttons_frame = ttk.Frame(glossary_display_frame) # Widget name changed
        glossary_display_buttons_frame.pack(fill="x", pady=5)

        self.load_glossary_button = ttk.Button(glossary_display_buttons_frame, text="용어집 불러오기", command=self._load_glossary_to_display) # Widget name, text, command changed
        self.load_glossary_button.pack(side="left", padx=5)
        Tooltip(self.load_glossary_button, "기존 용어집 JSON 파일을 불러와 아래 텍스트 영역에 표시합니다.") # Text changed

        self.copy_glossary_button = ttk.Button(glossary_display_buttons_frame, text="JSON 복사", command=self._copy_glossary_json) # Widget name, command changed
        self.copy_glossary_button.pack(side="left", padx=5)
        Tooltip(self.copy_glossary_button, "아래 텍스트 영역에 표시된 용어집 JSON 내용을 클립보드에 복사합니다.") # Text changed

        self.save_displayed_glossary_button = ttk.Button(glossary_display_buttons_frame, text="JSON 저장", command=self._save_displayed_glossary_json) # Widget name, command changed
        self.save_displayed_glossary_button.pack(side="left", padx=5)
        Tooltip(self.save_displayed_glossary_button, "아래 텍스트 영역에 표시된 용어집 JSON 내용을 새 파일로 저장합니다.") # Text changed

        self.edit_glossary_button = ttk.Button(glossary_display_buttons_frame, text="용어집 편집", command=self._open_glossary_editor) # Widget name, text, command changed
        self.edit_glossary_button.pack(side="left", padx=5)
        Tooltip(self.edit_glossary_button, "표시된 용어집 내용을 별도의 편집기 창에서 수정합니다.") # Text changed
        # 동적 용어집 주입 설정
        dynamic_glossary_frame = ttk.Labelframe(glossary_frame, text="동적 용어집 주입 설정", padding="10")
        dynamic_glossary_frame.pack(fill="x", padx=5, pady=5)

        self.enable_dynamic_glossary_injection_var = tk.BooleanVar()
        self.enable_dynamic_glossary_injection_check = ttk.Checkbutton(
            dynamic_glossary_frame,
            text="동적 용어집 주입 활성화",
            variable=self.enable_dynamic_glossary_injection_var
        )
        Tooltip(self.enable_dynamic_glossary_injection_check, "번역 시 용어집 탭에서 설정된 용어집 JSON 파일의 내용을\n프롬프트에 동적으로 주입하여 번역 일관성을 높입니다.")
        self.enable_dynamic_glossary_injection_check.grid(row=0, column=0, columnspan=3, padx=5, pady=2, sticky="w")

        max_entries_injection_label = ttk.Label(dynamic_glossary_frame, text="청크당 최대 주입 항목 수:")
        max_entries_injection_label.grid(row=1, column=0, padx=5, pady=5, sticky="w")
        Tooltip(max_entries_injection_label, "하나의 번역 청크에 주입될 용어집 항목의 최대 개수입니다.")
        self.max_glossary_entries_injection_entry = ttk.Entry(dynamic_glossary_frame, width=5)
        self.max_glossary_entries_injection_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")
        Tooltip(self.max_glossary_entries_injection_entry, "최대 주입 항목 수를 입력하세요.")

        max_chars_injection_label = ttk.Label(dynamic_glossary_frame, text="청크당 최대 주입 문자 수:")
        max_chars_injection_label.grid(row=2, column=0, padx=5, pady=5, sticky="w")
        Tooltip(max_chars_injection_label, "하나의 번역 청크에 주입될 용어집 내용의 최대 총 문자 수입니다.")
        self.max_glossary_chars_injection_entry = ttk.Entry(dynamic_glossary_frame, width=10)
        self.max_glossary_chars_injection_entry.grid(row=2, column=1, padx=5, pady=5, sticky="w")
        Tooltip(self.max_glossary_chars_injection_entry, "최대 주입 문자 수를 입력하세요.")




        # 설정 변경 감지 이벤트 바인딩
        self.sample_ratio_scale.bind("<ButtonRelease-1>", self._on_glossary_setting_changed) # Changed
        self.extraction_temp_scale.bind("<ButtonRelease-1>", self._on_glossary_setting_changed) # Changed
        self.user_override_glossary_prompt_text.bind("<KeyRelease>", self._on_glossary_setting_changed)
        
        # 제거된 UI 요소에 대한 바인딩도 제거


    def _create_log_widgets(self):
        self.log_text = scrolledtext.ScrolledText(self.log_tab, wrap=tk.WORD, state=tk.DISABLED, height=20)
        self.log_text.pack(fill="both", expand=True, padx=5, pady=5)
        Tooltip(self.log_text, "애플리케이션의 주요 동작 및 오류 로그가 표시됩니다.")
        
        gui_log_handler = TextHandler(self.log_text)
        # GUI 핸들러를 위한 별도의 포맷터 생성 및 설정
        gui_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', '%H:%M:%S')
        gui_log_handler.setFormatter(gui_formatter)
        
        # Use the global logger instance
        logger.addHandler(gui_log_handler)
        logger.setLevel(logging.INFO) # logging.INFO should be recognized

        self.tqdm_stream = TqdmToTkinter(self.log_text)

    def _log_message(self, message: str, level: str = "INFO", exc_info=False):
        gui_specific_logger = logging.getLogger(__name__ + "_gui")
        if level.upper() == "INFO": gui_specific_logger.info(message, exc_info=exc_info)
        elif level.upper() == "WARNING": gui_specific_logger.warning(message, exc_info=exc_info)
        elif level.upper() == "ERROR": gui_specific_logger.error(message, exc_info=exc_info) # type: ignore
        elif level.upper() == "DEBUG": gui_specific_logger.debug(message, exc_info=exc_info) # type: ignore
        else: gui_specific_logger.info(message, exc_info=exc_info) # type: ignore

    def _update_model_list_ui(self):
        app_service = self.app_service
        if not app_service:
            messagebox.showerror("오류", "AppService가 초기화되지 않았습니다.")
            self._log_message("모델 목록 업데이트 시도 실패: AppService 없음", "ERROR")
            return

        # 변수 스코프 문제 해결: try 블록 밖에서 정의
        current_user_input_model = self.model_name_combobox.get()
        
        try:
            self._log_message("모델 목록 새로고침 중...")
            
            # 1단계: 클라이언트 유무 확인
            if not app_service.gemini_client:
                # 클라이언트가 없다면, 설정을 저장하지 않고 사용자에게 알림.
                # AppService의 load_app_config를 호출하여 (저장 없이) 클라이언트 재설정을 시도할 수 있으나,
                # 여기서는 단순히 사용자에게 알리고 모델 목록 조회를 중단하는 것이 안전합니다.
                # load_app_config는 이미 AppService 초기화 시 또는 설정 저장/불러오기 시 호출됩니다.
                self._log_message(
                    "모델 목록 업데이트: Gemini 클라이언트가 초기화되지 않았습니다. "
                    "API 키 또는 Vertex AI 설정을 확인하고 '설정 저장' 후 다시 시도해주세요.", "WARNING"
                )
                messagebox.showwarning("인증 필요", 
                                       "모델 목록을 가져오려면 API 키 또는 Vertex AI 설정이 유효해야 합니다.\n"
                                       "설정을 확인하고 '설정 저장' 버튼을 누른 후 다시 시도해주세요.")
                self._reset_model_combobox(current_user_input_model)
                return
            
            # 3단계: 모델 목록 조회 (한 번만 호출)
            models_data = app_service.get_available_models()
            
            # 4단계: UI 모델 목록 구성
            model_display_names_for_ui = []
            for m in models_data:
                display_name = m.get("display_name")
                short_name = m.get("short_name")
                full_name = m.get("name")
                
                # 우선순위: short_name > display_name > full_name
                chosen_name_for_display = short_name or display_name or full_name
                
                if chosen_name_for_display and isinstance(chosen_name_for_display, str) and chosen_name_for_display.strip():
                    model_display_names_for_ui.append(chosen_name_for_display.strip())
            
            model_display_names_for_ui = sorted(list(set(model_display_names_for_ui)))
            self.model_name_combobox['values'] = model_display_names_for_ui
            
            # 5단계: 모델 선택 (우선순위에 따라)
            self._set_optimal_model_selection(current_user_input_model, model_display_names_for_ui)
            
            self._log_message(f"{len(model_display_names_for_ui)}개 모델 로드 완료.")

        except BtgApiClientException as e:
            messagebox.showerror("API 오류", f"모델 목록 조회 실패: {e}")
            self._log_message(f"모델 목록 조회 API 오류: {e}", "ERROR")
            self._reset_model_combobox(current_user_input_model)
        except BtgServiceException as e: 
            messagebox.showerror("서비스 오류", f"모델 목록 조회 실패: {e}")
            self._log_message(f"모델 목록 조회 서비스 오류: {e}", "ERROR")
            self._reset_model_combobox(current_user_input_model)
        except Exception as e:
            messagebox.showerror("오류", f"모델 목록 조회 중 예상치 못한 오류: {e}")
            self._log_message(f"모델 목록 조회 중 오류: {e}", "ERROR", exc_info=True)
            self._reset_model_combobox(current_user_input_model)


    def _browse_input_files(self): # 메서드 이름 변경 및 로직 수정
        filepaths = filedialog.askopenfilenames(
            title="입력 파일 선택",
            filetypes=(("텍스트 파일", "*.txt"), ("모든 파일", "*.*"))
        )
        if filepaths:
            for filepath in filepaths:
                if filepath not in self.input_file_listbox.get(0, tk.END):
                    self.input_file_listbox.insert(tk.END, filepath)
            # 자동 출력 경로 및 용어집 경로 제안 로직은 첫 번째 파일을 기준으로 유지하거나 수정할 수 있습니다.
            self._propose_paths_from_first_input()

    def _propose_paths_from_first_input(self):
        if self.input_file_listbox.size() > 0:
            first_file = self.input_file_listbox.get(0)
            p = Path(first_file)
            suggested_output = p.parent / f"{p.stem}_translated{p.suffix}"
            self.output_file_entry.delete(0, tk.END)
            self.output_file_entry.insert(0, str(suggested_output))

            if self.app_service:
                suffix = self.app_service.config.get('glossary_output_json_filename_suffix', '_glossary.json')
                suggested_glossary = p.parent / f"{p.stem}{suffix}"
                self.glossary_json_path_entry.delete(0, tk.END)
                self.glossary_json_path_entry.insert(0, str(suggested_glossary))


    def _remove_selected_files(self):
        selected_indices = self.input_file_listbox.curselection()
        # 인덱스가 큰 것부터 삭제해야 순서가 꼬이지 않습니다.
        for index in reversed(selected_indices):
            self.input_file_listbox.delete(index)



    def _browse_output_file(self):
        filepath = filedialog.asksaveasfilename(title="출력 파일 선택", defaultextension=".txt", filetypes=(("텍스트 파일", "*.txt"), ("모든 파일", "*.*")))
        if filepath:
            self.output_file_entry.delete(0, tk.END)
            self.output_file_entry.insert(0, filepath)

    def _browse_glossary_json(self): # Renamed
        
        initial_dir = ""
        input_file_path = ""
        # Check for selected items first
        selected_indices = self.input_file_listbox.curselection()
        if selected_indices:
            input_file_path = self.input_file_listbox.get(selected_indices[0])
        # If nothing is selected, use the first item in the list
        elif self.input_file_listbox.size() > 0:
            input_file_path = self.input_file_listbox.get(0)

        if input_file_path and Path(input_file_path).exists():
            initial_dir = str(Path(input_file_path).parent)
        
        filepath = filedialog.askopenfilename(
           title="용어집 JSON 파일 선택",  # Text changed
            
            filetypes=(("JSON 파일", "*.json"), ("모든 파일", "*.*")), # Type changed
            initialdir=initial_dir
            )
        if filepath:
            self.glossary_json_path_entry.delete(0, tk.END) # Changed
            self.glossary_json_path_entry.insert(0, filepath)



    def _get_config_from_ui(self) -> Dict[str, Any]:
        prompt_content = self.prompt_text.get("1.0", tk.END).strip()
        prefill_system_instruction_content = self.prefill_system_instruction_text.get("1.0", tk.END).strip()
        use_vertex = self.use_vertex_ai_var.get()

        api_keys_str = self.api_keys_text.get("1.0", tk.END).strip()
        api_keys_list = [key.strip() for key in api_keys_str.splitlines() if key.strip()]
       
        try:
            max_workers_val = int(self.max_workers_entry.get())
            if max_workers_val <= 0:
                max_workers_val = os.cpu_count() or 1 
                messagebox.showwarning("입력 오류", f"최대 작업자 수는 1 이상이어야 합니다. 기본값 ({max_workers_val})으로 설정됩니다.")
                self.max_workers_entry.delete(0, tk.END)
                self.max_workers_entry.insert(0, str(max_workers_val))
        except ValueError:
            max_workers_val = os.cpu_count() or 1 
            messagebox.showwarning("입력 오류", f"최대 작업자 수는 숫자여야 합니다. 기본값 ({max_workers_val})으로 설정됩니다.")
            self.max_workers_entry.delete(0, tk.END)
            self.max_workers_entry.insert(0, str(max_workers_val))

        try:
            rpm_val = float(self.rpm_entry.get() or "60.0")
            if rpm_val < 0: rpm_val = 0.0 # 0은 제한 없음, 음수는 0으로
        except ValueError:
            rpm_val = 60.0
            messagebox.showwarning("입력 오류", f"분당 요청 수는 숫자여야 합니다. 기본값 ({rpm_val})으로 설정됩니다.")
            self.rpm_entry.delete(0, tk.END)
            self.rpm_entry.insert(0, str(rpm_val))

        prefill_cached_history_json_str = self.prefill_cached_history_text.get("1.0", tk.END).strip()
        prefill_cached_history_obj = []
        if prefill_cached_history_json_str:
            try:
                prefill_cached_history_obj = json.loads(prefill_cached_history_json_str)
                if not isinstance(prefill_cached_history_obj, list):
                    messagebox.showwarning("입력 오류", "프리필 캐시된 히스토리는 JSON 배열이어야 합니다. 기본값 []으로 설정됩니다.")
                    prefill_cached_history_obj = []
            except json.JSONDecodeError:
                messagebox.showwarning("입력 오류", "프리필 캐시된 히스토리 형식이 잘못되었습니다 (JSON 파싱 실패). 기본값 []으로 설정됩니다.")
                prefill_cached_history_obj = []


        thinking_budget_str = self.thinking_budget_entry.get().strip()
        thinking_budget_ui_val: Optional[int] = None
        if thinking_budget_str:
            try:
                thinking_budget_ui_val = int(thinking_budget_str)
            except ValueError:
                messagebox.showwarning("입력 오류", f"Thinking Budget은 숫자여야 합니다. '{thinking_budget_str}'은(는) 유효하지 않습니다. 이 값은 무시됩니다.")
                self.thinking_budget_entry.delete(0, tk.END) # 잘못된 값 제거
                thinking_budget_ui_val = None # 잘못된 값이면 None으로 처리 (모델 기본값 사용)



        
        config_data = {
            "api_keys": api_keys_list if not use_vertex else [],
            "service_account_file_path": self.service_account_file_entry.get().strip() if use_vertex else None,
            "use_vertex_ai": use_vertex,
            "gcp_project": self.gcp_project_entry.get().strip() if use_vertex else None,
            "gcp_location": self.gcp_location_entry.get().strip() if use_vertex else None,
            "model_name": self.model_name_combobox.get().strip(), 
            "temperature": self.temperature_scale.get(),
            "top_p": self.top_p_scale.get(),
            "thinking_budget": thinking_budget_ui_val, # UI에서 가져온 thinking_budget 값
            "chunk_size": int(self.chunk_size_entry.get() or "6000"), 
            "user_override_glossary_extraction_prompt": self.user_override_glossary_prompt_text.get("1.0", tk.END).strip(),
            "max_workers": max_workers_val, 
            "requests_per_minute": rpm_val,
            "prompts": prompt_content,
            "enable_prefill_translation": self.enable_prefill_var.get(),
            "prefill_system_instruction": prefill_system_instruction_content,
            "prefill_cached_history": prefill_cached_history_obj,            
            "novel_language": self.novel_language_entry.get().strip() or "auto",
            "novel_language_fallback": self.novel_language_fallback_entry.get().strip() or "ja",
            # Lorebook settings
            "glossary_json_path": self.glossary_json_path_entry.get().strip() or None, # Key and widget name changed
            "glossary_sampling_ratio": self.sample_ratio_scale.get(), 
            "glossary_extraction_temperature": self.extraction_temp_scale.get(), # Key changed
                
                # Dynamic lorebook injection settings
                "enable_dynamic_glossary_injection": self.enable_dynamic_glossary_injection_var.get(), # Key and var name changed
                "max_glossary_entries_per_chunk_injection": int(self.max_glossary_entries_injection_entry.get() or "3"), # Key and widget name changed
                "max_glossary_chars_per_chunk_injection": int(self.max_glossary_chars_injection_entry.get() or "500"), # Key and widget name changed
                
                # lorebook_json_path_for_injection 은 lorebook_json_path 로 통합되었으므로 여기서 제거
            "use_content_safety_retry": self.use_content_safety_retry_var.get(), # type: ignore
            "max_content_safety_split_attempts": int(self.max_split_attempts_entry.get() or "3"), # type: ignore
            "min_content_safety_chunk_size": int(self.min_chunk_size_entry.get() or "100"), # type: ignore
        }
        
        return config_data

    def _save_settings(self):
        app_service = self.app_service
        if not app_service:
            messagebox.showerror("오류", "AppService가 초기화되지 않았습니다.")
            return
        try:
            current_config = app_service.config.copy()
            ui_config = self._get_config_from_ui()
            current_config.update(ui_config)
            app_service.save_app_config(current_config)
            messagebox.showinfo("성공", "설정이 성공적으로 저장되었습니다.")
            self._log_message("설정 저장됨.")
            self._load_initial_config_to_ui() 
        except ValueError as ve: 
            messagebox.showerror("입력 오류", f"설정값 오류: {ve}")
            self._log_message(f"설정값 입력 오류: {ve}", "ERROR")
        except BtgConfigException as e:
            messagebox.showerror("설정 저장 오류", f"설정 저장 중 오류: {e}")
            self._log_message(f"설정 저장 오류: {e}", "ERROR")
        except Exception as e:
            messagebox.showerror("오류", f"설정 저장 중 예상치 못한 오류: {e}")
            self._log_message(f"설정 저장 중 예상치 못한 오류: {e}", "ERROR", exc_info=True)

    def _load_settings_ui(self):
        app_service = self.app_service
        if not app_service:
            messagebox.showerror("오류", "AppService가 초기화되지 않았습니다.")
            return
        try:
            app_service.load_app_config()
            self._load_initial_config_to_ui()
            messagebox.showinfo("성공", "설정을 성공적으로 불러왔습니다.")
            self._log_message("설정 불러옴.")
        except BtgConfigException as e:
            messagebox.showerror("설정 불러오기 오류", f"설정 불러오기 중 오류: {e}")
            self._log_message(f"설정 불러오기 오류: {e}", "ERROR")
        except Exception as e:
            messagebox.showerror("오류", f"설정 불러오기 중 예상치 못한 오류: {e}")
            self._log_message(f"설정 불러오기 중 오류: {e}", "ERROR", exc_info=True)

    def _update_translation_progress(self, dto: TranslationJobProgressDTO):
        def _update():
            if not self.master.winfo_exists(): return 
            self.progress_bar['value'] = (dto.processed_chunks / dto.total_chunks) * 100 if dto.total_chunks > 0 else 0
            status_text = f"{dto.current_status_message} ({dto.processed_chunks}/{dto.total_chunks})"
            if dto.failed_chunks > 0:
                status_text += f" - 실패: {dto.failed_chunks}"
            if dto.last_error_message:
                status_text += f" (마지막 오류: {dto.last_error_message[:30]}...)"
            self.progress_label.config(text=status_text)
        if self.master.winfo_exists():
            self.master.after(0, _update)

    def _update_translation_status(self, message: str):
        def _update():
            # This method is now only for logging and button state management,
            # not for progress text or completion popups.
            self._log_message(f"번역 상태: {message}")
            if "번역 시작됨" in message or "번역 중..." in message or "처리 중" in message or "준비 중" in message :
                self.start_button.config(state=tk.DISABLED)
                self.stop_button.config(state=tk.NORMAL)
            # The final state update is handled in _run_multiple_translations_sequentially
            elif "오류" in message or "중단" in message:
                self.start_button.config(state=tk.NORMAL)
                self.stop_button.config(state=tk.DISABLED)
                
        if self.master.winfo_exists():
            self.master.after(0, _update)

    def _show_completion_notification(self, title: str, message: str):
        """번역 완료 시 알림 팝업을 표시합니다."""
        try:
            messagebox.showinfo(title, message)
        except Exception as e:
            self._log_message(f"번역 완료 알림 표시 중 오류: {e}", "ERROR")

    def _start_translation_thread(self, retranslate_failed_only: bool = False):
          app_service = self.app_service
          if not app_service:
              messagebox.showerror("오류", "애플리케이션 서비스가 초기화되지 않았습니다.")
              return

          input_files = self.input_file_listbox.get(0, tk.END)
          if not input_files:
              messagebox.showwarning("경고", "입력 파일을 하나 이상 추가해주세요.")
              return

          self.stop_requested = False

          # Run the sequential translation in a separate thread
          thread = threading.Thread(
              target=self._run_multiple_translations_sequentially,
              args=(list(input_files), retranslate_failed_only),
              daemon=True
          )
          thread.start()

    def _start_translation_thread_with_resume_check(self):
        self._start_translation_thread(retranslate_failed_only=False)

    def _start_failed_chunks_translation_thread(self):
        self._start_translation_thread(retranslate_failed_only=True)

    def _run_multiple_translations_sequentially(self, input_files: list, retranslate_failed_only: bool =
False):
        """
        입력 파일 목록을 순회하며 하나씩 번역을 실행하고, 모든 작업 완료 후 알림을 표시합니다.
        """
        # 작업 시작 시 버튼 상태 업데이트
        self.master.after(0, lambda: self.start_button.config(state=tk.DISABLED))
        self.master.after(0, lambda: self.retry_failed_button.config(state=tk.DISABLED))
        self.master.after(0, lambda: self.stop_button.config(state=tk.NORMAL))

        app_service = self.app_service
        if not app_service:
            self.master.after(0, lambda: self.start_button.config(state=tk.NORMAL))
            self.master.after(0, lambda: self.retry_failed_button.config(state=tk.NORMAL))
            self.master.after(0, lambda: self.stop_button.config(state=tk.DISABLED))
            return

        total_files = len(input_files)
        completed_files = []
        failed_files = []

        # Apply UI settings before starting
        try:
            current_ui_config = self._get_config_from_ui()
            app_service.load_app_config(runtime_overrides=current_ui_config)
            if not self.app_service.gemini_client:
                if not messagebox.askyesno("API 설정 경고", "API 클라이언트가 초기화되지 않았습니다.(인증 정보 확인 필요)\n계속 진행하시겠습니까?"):
                    self.master.after(0, lambda: self.start_button.config(state=tk.NORMAL))
                    self.master.after(0, lambda: self.retry_failed_button.config(state=tk.NORMAL))
                    self.master.after(0, lambda: self.stop_button.config(state=tk.DISABLED))
                    return
        except Exception as e:
            messagebox.showerror("오류", f"번역 시작 전 설정 오류: {e}")
            self.master.after(0, lambda: self.start_button.config(state=tk.NORMAL))
            self.master.after(0, lambda: self.retry_failed_button.config(state=tk.NORMAL))
            self.master.after(0, lambda: self.stop_button.config(state=tk.DISABLED))
            return

        for i, input_file in enumerate(input_files):
            if self.stop_requested:
                self._log_message("사용자 요청으로 다중 파일 번역 작업을 중단합니다.")
                break

            self._log_message(f"=== 파일 {i+1}/{total_files} 번역 시작: {Path(input_file).name} ===")
            self.master.after(0, lambda: self.progress_label.config(text=f"{Path(input_file).name} 번역 준비 중...")) # Changed

            p = Path(input_file)
            output_file = p.parent / f"{p.stem}_translated{p.suffix}"

            translation_done_event = threading.Event()
            translation_status = {"message": ""}

            def translation_finished_callback(message: str):
                """Callback to be invoked when translation is finished, stopped, or has an error."""
                if "완료" in message or "오류" in message or "중단" in message:
                    translation_status["message"] = message
                    translation_done_event.set()

            app_service.start_translation(
                input_file_path=input_file,
                output_file_path=str(output_file),
                progress_callback=self._update_translation_progress,
                status_callback=translation_finished_callback,
                tqdm_file_stream=self.tqdm_stream,
                retranslate_failed_only=retranslate_failed_only
            )

            translation_done_event.wait() # Wait for the translation of the current file to complete

            if "오류" in translation_status["message"] or "중단" in translation_status["message"]:
                failed_files.append(Path(input_file).name)
            else:
                completed_files.append(Path(input_file).name)

            self._log_message(f"=== 파일 {i+1}/{total_files} 처리 완료: {Path(input_file).name} ===")

        # After all files are processed, show a final summary notification.
        final_title = "배치 번역 완료"
        final_message = f"총 {total_files}개 파일 중 {len(completed_files)}개 성공, {len(failed_files)}개 실패/중단.\\n\\n"
        if completed_files:
            final_message += f"성공:\\n- " + "\\n- ".join(completed_files)
        if failed_files:
            final_message += f"\\n\\n실패/중단:\\n- " + "\\n- ".join(failed_files)

        self.master.after(0, lambda: self._show_completion_notification(final_title, final_message))
        self.master.after(0, lambda: self.progress_label.config(text="모든 파일 작업 완료."))
        self.master.after(0, lambda: self.start_button.config(state=tk.NORMAL))
        self.master.after(0, lambda: self.retry_failed_button.config(state=tk.NORMAL))
        self.master.after(0, lambda: self.stop_button.config(state=tk.DISABLED))

    def _request_stop_translation(self):
        app_service = self.app_service
        if not app_service: return
        if app_service.is_translation_running:
            self.stop_requested = True # GUI 레벨의 중지 플래그 설정
            app_service.request_stop_translation()
            self._log_message("번역 중지 요청됨.")
            self.stop_button.config(state=tk.DISABLED) # 중지 버튼 비활성화
        else:
            self._log_message("실행 중인 번역 작업이 없습니다.")

    def _update_glossary_extraction_progress(self, dto: GlossaryExtractionProgressDTO): # Renamed and DTO changed
        
        def _update():
            if not self.master.winfo_exists(): return
            msg = f"{dto.current_status_message} ({dto.processed_segments}/{dto.total_segments}, 추출 항목: {dto.extracted_entries_count})" # DTO fields changed
            self.glossary_progress_label.config(text=msg) # Changed
        
        if self.master.winfo_exists():
            self.master.after(0, _update)

    def _extract_glossary_thread(self): # Renamed
        
        app_service = self.app_service
        if not app_service:
            messagebox.showerror("오류", "애플리케이션 서비스가 초기화되지 않았습니다.")
            return

        selected_indices = self.input_file_listbox.curselection()
        if not selected_indices:
            if self.input_file_listbox.size() > 0:
                # 파일이 선택되지 않았지만 목록에 파일이 있으면 첫 번째 항목을 자동으로 선택
                self.input_file_listbox.selection_set(0)
                selected_indices = self.input_file_listbox.curselection()
                self._log_message("선택된 파일이 없어 첫 번째 파일을 자동으로 선택합니다.", "INFO")
            else:
                messagebox.showwarning("경고", "입력 파일을 먼저 추가해주세요.")
                return
        
        input_file = self.input_file_listbox.get(selected_indices[0])

        if not input_file:
            messagebox.showwarning("경고", "용어집을 추출할 입력 파일을 먼저 선택해주세요.")
            return
        if not Path(input_file).exists():
            messagebox.showerror("오류", f"입력 파일을 찾을 수 없습니다: {input_file}")
            return

        try:
            current_ui_config = self._get_config_from_ui()
            app_service.load_app_config(runtime_overrides=current_ui_config)

            if not app_service.gemini_client:
                 if not messagebox.askyesno("API 설정 경고", "API 클라이언트가 초기화되지 않았습니다. 계속 진행하시겠습니까?"):
                    return
                 
            # type: ignore

        except ValueError as ve:
             messagebox.showerror("입력 오류", f"설정값 오류: {ve}")
             return
        except Exception as e:
            messagebox.showerror("오류", f"용어집 추출 시작 전 설정 오류: {e}") # Text changed
            self._log_message(f"용어집 추출 시작 전 설정 오류: {e}", "ERROR", exc_info=True) # Text changed
            return

        self.glossary_progress_label.config(text="용어집 추출 시작 중...") # Changed
        self._log_message(f"용어집 추출 시작: {input_file}") # Text changed
        
        # Manage button states and flag
        self.glossary_stop_requested = False
        self.extract_glossary_button.config(state=tk.DISABLED)
        self.stop_glossary_button.config(state=tk.NORMAL)
        
        # GUI에서 직접 소설 언어를 입력받는 UI가 제거되었으므로, 항상 None을 전달하여 AppService가 설정을 따르도록 합니다.
        def _extraction_task_wrapper():
            try:
                if app_service:
                    result_json_path = app_service.extract_glossary(
                        input_file,
                        progress_callback=self._update_glossary_extraction_progress, # Callback changed                      
                        seed_glossary_path=app_service.config.get("glossary_json_path"), # Use current glossary as seed
                        user_override_glossary_extraction_prompt=app_service.config.get("user_override_glossary_extraction_prompt"), # Pass override prompt
                        stop_check=lambda: self.glossary_stop_requested
                    )
                    
                    if self.glossary_stop_requested:
                        self.master.after(0, lambda: messagebox.showinfo("중지됨", f"용어집 추출이 중지되었습니다.\n현재까지의 결과가 저장되었습니다: {result_json_path}"))
                    else:
                        self.master.after(0, lambda: messagebox.showinfo("성공", f"용어집 추출 완료!\n결과 파일: {result_json_path}"))

                    self.master.after(0, lambda: self.glossary_progress_label.config(text=f"추출 완료: {result_json_path.name}")) # Changed
                    self.master.after(0, lambda: self._update_glossary_json_path_entry(str(result_json_path))) # Changed
                    # Load result to display
                    if result_json_path and result_json_path.exists(): # Check if result_json_path is not None
                        with open(result_json_path, 'r', encoding='utf-8') as f_res:
                            lore_content = f_res.read()
                        self.master.after(0, lambda: self._display_glossary_content(lore_content)) # Function name changed
            
            # BtgPronounException replaced with BtgBusinessLogicException as SimpleGlossaryService might throw more general business logic errors
            except (BtgFileHandlerException, BtgApiClientException, BtgServiceException, BtgBusinessLogicException) as e_btg:
                logger.error(f"용어집 추출 중 BTG 예외 발생: {e_btg}", exc_info=True) # Text changed
                self.master.after(0, lambda: messagebox.showerror("추출 오류", f"용어집 추출 중 오류: {e_btg}")) # Text changed
                self.master.after(0, lambda: self.glossary_progress_label.config(text="오류 발생")) # Changed
            except Exception as e_unknown: 
                logger.error(f"용어집 추출 중 알 수 없는 예외 발생: {e_unknown}", exc_info=True) # Text changed
                self.master.after(0, lambda: messagebox.showerror("알 수 없는 오류", f"용어집 추출 중 예상치 못한 오류: {e_unknown}")) # Text changed
                self.master.after(0, lambda: self.glossary_progress_label.config(text="알 수 없는 오류 발생")) # Changed
            finally:
                self.master.after(0, lambda: self.extract_glossary_button.config(state=tk.NORMAL))
                self.master.after(0, lambda: self.stop_glossary_button.config(state=tk.DISABLED))
                self._log_message("용어집 추출 스레드 종료.")

        thread = threading.Thread(target=_extraction_task_wrapper, daemon=True)
        thread.start()

    def _update_glossary_json_path_entry(self, path_str: str): # Renamed
        self.glossary_json_path_entry.delete(0, tk.END) # Changed
        self.glossary_json_path_entry.insert(0, path_str)
        
        if self.app_service:
            self.app_service.config["glossary_json_path"] = path_str # type: ignore # Key changed



    def _on_closing(self):
        app_service = self.app_service
        if app_service and app_service.is_translation_running:
            if messagebox.askokcancel("종료 확인", "번역 작업이 진행 중입니다. 정말로 종료하시겠습니까?"):
                self.stop_requested = True
                app_service.request_stop_translation()
                logger.info("사용자 종료 요청으로 번역 중단 시도.")
                # 앱 서비스가 완전히 멈출 때까지 100ms 마다 확인 후 창을 닫습니다.
                self._check_if_stopped_and_destroy()
        else:
            self.master.destroy()

    def _check_if_stopped_and_destroy(self):
        # app_service가 없거나 번역이 실행 중이 아니면 즉시 창을 닫습니다.
        if not self.app_service or not self.app_service.is_translation_running:
            self.master.destroy()
        else:
            # 아직 실행 중이면 100ms 후에 다시 확인합니다.
            self.master.after(100, self._check_if_stopped_and_destroy)

    def _on_api_key_changed(self, event=None):
        # type: ignore
        """API 키가 변경되었을 때 클라이언트 초기화 상태 리셋"""
        if hasattr(self, 'app_service') and self.app_service:
            # 다음 모델 새로고침 시 자동으로 재초기화되도록 플래그 설정
            self._client_needs_refresh = True

    def _reset_model_combobox(self, current_user_input_model: str):
        """모델 콤보박스를 초기 상태로 리셋"""
        self.model_name_combobox['values'] = []
        self.model_name_combobox.set(current_user_input_model)

    def _set_optimal_model_selection(self, current_user_input_model: str, model_display_names_for_ui: List[str]):
        """최적의 모델 선택 로직"""
        app_service = self.app_service
        config_model_name = app_service.config.get("model_name", "") if app_service else "" # type: ignore
        config_model_short_name = config_model_name.split('/')[-1] if '/' in config_model_name else config_model_name

        # 우선순위에 따른 모델 선택
        if current_user_input_model and current_user_input_model.strip() in model_display_names_for_ui:
            self.model_name_combobox.set(current_user_input_model)
        elif config_model_short_name and config_model_short_name in model_display_names_for_ui:
            self.model_name_combobox.set(config_model_short_name)
        elif config_model_name and config_model_name in model_display_names_for_ui:
            self.model_name_combobox.set(config_model_name)
        elif model_display_names_for_ui:
            self.model_name_combobox.set(model_display_names_for_ui[0])
        else:
            self.model_name_combobox.set("")


    def _update_sample_ratio_label(self, value):
        """샘플링 비율 레이블 업데이트"""
        ratio = float(value)
        self.sample_ratio_label.config(text=f"{ratio:.1f}%")

    def _validate_max_entries_segment(self, value): # Renamed
        """세그먼트 당 최대 항목 수 유효성 검사"""
        if value == "":
            return True
        try:
            num = int(value)
            return 1 <= num <= 50 # Adjusted range
        except ValueError:
            return False

    
    def _update_max_entries_segment_label(self): # New or adapted
        pass # Label might not be needed if spinbox is clear

    def _update_extraction_temp_label(self, value):
        """추출 온도 레이블 업데이트"""
        temp = float(value)
        # extraction_temp_label이 존재하는지 확인
        if hasattr(self, 'extraction_temp_label'):
            self.extraction_temp_label.config(text=f"{temp:.2f}")

    def _toggle_advanced_settings(self):
        """고급 설정 표시/숨김 토글"""
        if self.advanced_var.get():
            self.advanced_frame.grid()
        else:
            self.advanced_frame.grid_remove()

    def _show_sampling_estimate(self):
        """샘플링 비율에 따른 예상 처리량 표시"""
        input_file = ""
        selected_indices = self.input_file_listbox.curselection()
        if selected_indices:
            input_file = self.input_file_listbox.get(selected_indices[0])
        elif self.input_file_listbox.size() > 0:
            input_file = self.input_file_listbox.get(0)
        else:
            return

        if not input_file or not Path(input_file).exists():
            return
        
        try:
            # 파일 크기 기반 추정
            file_size = Path(input_file).stat().st_size
            chunk_size = int(self.chunk_size_entry.get() or "6000")
            estimated_chunks = file_size // chunk_size
            
            sample_ratio = self.sample_ratio_scale.get() / 100.0
            estimated_sample_chunks = int(estimated_chunks * sample_ratio)
            
            # 추정 정보를 툴팁이나 레이블로 표시
            estimate_text = f"예상 분석 청크: {estimated_sample_chunks}/{estimated_chunks}"
            
            # 기존 레이블이 있다면 업데이트, 없다면 생성
            
            # if hasattr(self, 'sampling_estimate_label'):
            #     self.sampling_estimate_label.config(text=estimate_text)
            
            
        except Exception:
            pass  # 추정 실패 시 무시

    def _save_glossary_settings(self): # Renamed
        
        """로어북 관련 설정만 저장"""
        app_service = self.app_service
        if not app_service: # type: ignore

            messagebox.showerror("오류", "AppService가 초기화되지 않았습니다.")
            return
        
        try:
            # 현재 전체 설정 가져오기
            current_config = app_service.config.copy()
            
            # 고유명사 관련 설정만 업데이트
            glossary_config = self._get_glossary_config_from_ui()
            current_config.update(glossary_config)
            
            # type: ignore
            # 설정 저장
            # AppService의 save_app_config가 load_app_config를 호출하므로, UI 업데이트는 거기서 처리될 수 있음
            if self.app_service.save_app_config(current_config): # type: ignore
                messagebox.showinfo("성공", "용어집 설정이 저장되었습니다.")
                self._log_message("용어집 설정 저장 완료.")
                self._update_glossary_status_label("✅ 설정 저장됨")
            else:
                messagebox.showerror("오류", "용어집 설정 저장에 실패했습니다.")
                
                
        except Exception as e:
            messagebox.showerror("오류", f"설정 저장 중 오류: {e}")
            self._log_message(f"용어집 설정 저장 오류: {e}", "ERROR") # Text changed

    def _get_glossary_config_from_ui(self) -> Dict[str, Any]: # Renamed        
        """UI에서 로어북 관련 설정만 추출"""
        app_service = self.app_service
        if not app_service:
            logger.error("AppService not initialized in _get_glossary_config_from_ui") # Text changed
            
            return {}
        try:
            config = {
                "glossary_json_path": self.glossary_json_path_entry.get().strip() or None, # Key and widget name changed
                "glossary_sampling_ratio": self.sample_ratio_scale.get(),
                "glossary_extraction_temperature": self.extraction_temp_scale.get(),                     
                # Dynamic lorebook injection settings
                "enable_dynamic_glossary_injection": self.enable_dynamic_glossary_injection_var.get(), # Key and var name changed
                "max_glossary_entries_per_chunk_injection": int(self.max_glossary_entries_injection_entry.get() or "3"), # Key and widget name changed
                "max_glossary_chars_per_chunk_injection": int(self.max_glossary_chars_injection_entry.get() or "500"), # Key and widget name changed
                "user_override_glossary_extraction_prompt": self.user_override_glossary_prompt_text.get("1.0", tk.END).strip()
            }
            
            # 제거된 UI 요소에 대한 설정 추출 로직도 제거
            # 예: glossary_max_entries_per_segment, glossary_sampling_method 등


            return {k: v for k, v in config.items() if v is not None}
        except Exception as e:
            raise ValueError(f"용어집 설정 값 오류: {e}") # Text changed

    def _reset_glossary_settings(self): # Renamed      
        """로어북 설정을 기본값으로 초기화"""
        app_service = self.app_service
        if not app_service or not app_service.config_manager:
            messagebox.showerror("오류", "AppService 또는 ConfigManager가 초기화되지 않았습니다.")
            return # type: ignore
        
        result = messagebox.askyesno( # type: ignor            
            "설정 초기화", 
            "용어집 설정을 기본값으로 초기화하시겠습니까?" # Text changed     
        )
        
        if result:
            try:
                # 기본값 로드
                default_config = app_service.config_manager.get_default_config()
                # UI에 기본값 적용
                self.sample_ratio_scale.set(default_config.get("glossary_sampling_ratio", 10.0))
                self.extraction_temp_scale.set(default_config.get("glossary_extraction_temperature", 0.3))
                self.user_override_glossary_prompt_text.delete('1.0', tk.END)
                self.user_override_glossary_prompt_text.insert('1.0', default_config.get("user_override_glossary_extraction_prompt", ""))
                # 제거된 UI 요소에 대한 초기화 로직도 제거
                

                # 레이블 업데이트
                self._update_sample_ratio_label(str(self.sample_ratio_scale.get()))
                self._update_extraction_temp_label(str(self.extraction_temp_scale.get()))
                
                self._update_glossary_status_label("🔄 기본값으로 초기화됨") # Changed
                self._log_message("용어집 설정이 기본값으로 초기화되었습니다.") # Text changed
                              
            except Exception as e:
                messagebox.showerror("오류", f"기본값 로드 중 오류: {e}")

    def _preview_glossary_settings(self): # Renamed        
        """현재 설정의 예상 효과 미리보기"""
        try:
            input_file = ""
            selected_indices = self.input_file_listbox.curselection()
            if selected_indices:
                input_file = self.input_file_listbox.get(selected_indices[0])
            elif self.input_file_listbox.size() > 0:
                input_file = self.input_file_listbox.get(0)
            else:
                messagebox.showwarning("파일 없음", "'설정 및 번역' 탭에서 입력 파일을 먼저 추가하고 선택해주세요.")
                return

            if not input_file or not Path(input_file).exists():
                messagebox.showwarning("파일 없음", f"선택한 파일을 찾을 수 없습니다: {input_file}")
                return
            
            # type: ignore
            # 현재 설정 값들
            sample_ratio = self.sample_ratio_scale.get()
            extraction_temp = self.extraction_temp_scale.get() # This is lorebook_extraction_temperature
            
            # 파일 크기 기반 추정
            file_size = Path(input_file).stat().st_size
            chunk_size = int(self.chunk_size_entry.get() or "6000")
            estimated_chunks = max(1, file_size // chunk_size)
            estimated_sample_chunks = max(1, int(estimated_chunks * sample_ratio / 100.0))
            
            # 미리보기 정보 표시
            preview_msg = (
                f"📊 용어집 추출 설정 미리보기\n\n" # Text changed               
                f"📁 입력 파일: {Path(input_file).name}\n"
                f"📏 파일 크기: {file_size:,} 바이트\n"
                f"🧩 예상 청크 수: {estimated_chunks:,}개\n"
                f"🎯 분석할 샘플: {estimated_sample_chunks:,}개 ({sample_ratio:.1f}%)\n"
                f"🌡️ 추출 온도: {extraction_temp:.2f}\n\n"
                f"⏱️ 예상 처리 시간: {estimated_sample_chunks * 2:.0f}~{estimated_sample_chunks * 5:.0f}초"
            )
            
            messagebox.showinfo("설정 미리보기", preview_msg)
        except Exception as e:
            messagebox.showerror("오류", f"미리보기 생성 중 오류: {e}")

    def _update_glossary_status_label(self, message: str): # Renamed       
        """로어북 설정 상태 업데이트"""
        if hasattr(self, 'glossary_status_label'): # Changed
            self.glossary_status_label.config(text=message) # Changed
                       
            # 3초 후 기본 메시지로 복귀
            self.master.after(3000, lambda: self.glossary_status_label.config( # Changed             
                text="⏸️ 설정 변경 대기 중..."
            ))

    def _on_glossary_setting_changed(self, event=None): # Renamed      
        """로어북 설정이 변경될 때 호출"""
        self._update_glossary_status_label("⚠️ 설정이 변경됨 (저장 필요)") # Changed
        
        # 저장 버튼 강조
        if hasattr(self, 'save_glossary_settings_button'): # Changed
            self.save_glossary_settings_button.config(style="Accent.TButton") # Changed

    def _display_glossary_content(self, content: str): # Renamed
        self.glossary_display_text.config(state=tk.NORMAL) # Widget name changed
        self.glossary_display_text.delete('1.0', tk.END)
        self.glossary_display_text.insert('1.0', content)
        self.glossary_display_text.config(state=tk.DISABLED)

    def _load_glossary_to_display(self): # Renamed
        filepath = filedialog.askopenfilename(title="용어집 JSON 파일 선택", filetypes=(("JSON 파일", "*.json"), ("모든 파일", "*.*"))) # Text changed
        
        if filepath:
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                self._display_glossary_content(content) # Function name changed
                self.glossary_json_path_entry.delete(0, tk.END) # Widget name changed
                self.glossary_json_path_entry.insert(0, filepath)
                self._log_message(f"용어집 파일 로드됨: {filepath}") # Text changed
            
            except Exception as e:
                messagebox.showerror("오류", f"용어집 파일 로드 실패: {e}") # Text changed
                self._log_message(f"용어집 파일 로드 실패: {e}", "ERROR") # Text changed

    def _copy_glossary_json(self): # Renamed
        content = self.glossary_display_text.get('1.0', tk.END).strip() # Widget name changed      
        if content:
            self.master.clipboard_clear()
            self.master.clipboard_append(content)
            messagebox.showinfo("성공", "용어집 JSON 내용이 클립보드에 복사되었습니다.") # Text changed
            self._log_message("용어집 JSON 클립보드에 복사됨.") # Text changed        
        else:
            messagebox.showwarning("경고", "복사할 내용이 없습니다.")

    def _save_displayed_glossary_json(self): # Renamed
        content = self.glossary_display_text.get('1.0', tk.END).strip() # Widget name changed       
        if not content:
            messagebox.showwarning("경고", "저장할 내용이 없습니다.")
            return
        
        filepath = filedialog.asksaveasfilename(title="용어집 JSON으로 저장", defaultextension=".json", filetypes=(("JSON 파일", "*.json"), ("모든 파일", "*.*"))) # Text changed    
        if filepath:
            try:
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(content)
                messagebox.showinfo("성공", f"로어북이 성공적으로 저장되었습니다: {filepath}")
                self._log_message(f"표시된 로어북 저장됨: {filepath}")
            except Exception as e:
                messagebox.showerror("오류", f"용어집 저장 실패: {e}") # Text changed
                self._log_message(f"표시된 용어집 저장 실패: {e}", "ERROR") # Text changed

    def _open_glossary_editor(self): # Renamed
        current_json_str = self.glossary_display_text.get('1.0', tk.END).strip() # Widget name changed       
        if not current_json_str:
            if not messagebox.askyesno("용어집 비어있음", "표시된 용어집 내용이 없습니다. 새 용어집을 만드시겠습니까?"): # Text changed
                return
            current_json_str = "[]" # 새 용어집을 위한 빈 리스트

        try:
            # JSON 유효성 검사
            json.loads(current_json_str)
        except json.JSONDecodeError as e:
            messagebox.showerror("JSON 오류", f"용어집 내용이 유효한 JSON 형식이 아닙니다: {e}") # Text changed           
            return

        input_file_path = ""
        selected_indices = self.input_file_listbox.curselection()
        if selected_indices:
            input_file_path = self.input_file_listbox.get(selected_indices[0])

        editor_window = GlossaryEditorWindow(self.master, current_json_str, self._handle_glossary_editor_save, input_file_path) # Class and callback changed
        editor_window.grab_set() # Modal-like behavior

    def _handle_glossary_editor_save(self, updated_json_str: str): # Renamed
        self._display_glossary_content(updated_json_str) # Function name changed
        self._log_message("용어집 편집기에서 변경 사항이 적용되었습니다.") # Text changed      
        # Optionally, ask user if they want to save to the file now
        if messagebox.askyesno("파일 저장 확인", "편집된 용어집을 현재 설정된 JSON 파일 경로에 저장하시겠습니까?"): # Text changed
            glossary_file_path = self.glossary_json_path_entry.get() # Widget name changed
            if glossary_file_path:
                try:
                    with open(glossary_file_path, 'w', encoding='utf-8') as f:
                        
                        f.write(updated_json_str)
                    messagebox.showinfo("저장 완료", f"용어집이 '{glossary_file_path}'에 저장되었습니다.") # Text changed
                    self._log_message(f"편집된 용어집 파일 저장됨: {glossary_file_path}") # Text changed
                
                except Exception as e:
                    messagebox.showerror("파일 저장 오류", f"용어집 파일 저장 실패: {e}") # Text changed
                    self._log_message(f"편집된 용어집 파일 저장 실패: {e}", "ERROR") # Text changed
            
            else:
                messagebox.showwarning("경로 없음", "용어집 JSON 파일 경로가 설정되지 않았습니다. 'JSON 저장' 버튼을 사용하거나 경로를 설정해주세요.") # Text changed


class GlossaryEditorWindow(tk.Toplevel): # Class name changed
    def __init__(self, master, glossary_json_str: str, save_callback: Callable[[str], None], input_file_path: str): # Parameter name changed      
        super().__init__(master)
        self.title("용어집 편집기") # Text changed
        self.geometry("800x600")
        self.save_callback = save_callback
        self.input_file_path = input_file_path

        try:
            self.glossary_data: List[Dict[str, Any]] = json.loads(glossary_json_str) # Var name changed
            if not isinstance(self.glossary_data, list): # Ensure it's a list
                raise ValueError("Glossary data must be a list of entries.") # Text changed      
        except (json.JSONDecodeError, ValueError) as e:
            messagebox.showerror("데이터 오류", f"용어집 데이터를 불러오는 중 오류 발생: {e}", parent=self) # Text changed
            self.glossary_data = [] # Fallback to empty list, var name changed

        self.current_selection_index: Optional[int] = None

        # Main frame
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Left: Listbox for keywords
        listbox_frame = ttk.Frame(main_frame)
        listbox_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))

        self.listbox_scrollbar = ttk.Scrollbar(listbox_frame, orient=tk.VERTICAL)
        self.listbox_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.listbox = tk.Listbox(listbox_frame, width=30, height=20, exportselection=False, yscrollcommand=self.listbox_scrollbar.set)
        self.listbox.pack(side=tk.TOP, fill=tk.Y, expand=True)
        self.listbox_scrollbar.config(command=self.listbox.yview)

        self.listbox.bind("<<ListboxSelect>>", self._on_listbox_select)

        listbox_buttons_frame = ttk.Frame(listbox_frame)
        listbox_buttons_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(5,0))
        ttk.Button(listbox_buttons_frame, text="새 항목", command=self._add_new_entry).pack(side=tk.LEFT, expand=True, fill=tk.X)
        ttk.Button(listbox_buttons_frame, text="항목 삭제", command=self._delete_selected_entry).pack(side=tk.LEFT, expand=True, fill=tk.X)


        # Right: Entry fields for selected item
        self.entry_fields_frame = ttk.Frame(main_frame)
        self.entry_fields_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        fields = {
            "keyword": {"label": "키워드:", "widget": ttk.Entry, "height": 1},
            "translated_keyword": {"label": "번역된 키워드:", "widget": ttk.Entry, "height": 1},
            # "source_language": {"label": "출발 언어 (BCP-47):", "widget": ttk.Entry, "height": 1}, # 제거
            "target_language": {"label": "도착 언어 (BCP-47):", "widget": ttk.Entry, "height": 1},
            "occurrence_count": {"label": "등장 횟수:", "widget": ttk.Spinbox, "height": 1, "extra_args": {"from_": 0, "to": 9999}},
        }

        self.entry_widgets: Dict[str, Union[ttk.Entry, tk.Text, ttk.Spinbox, ttk.Checkbutton]] = {}

        for i, (field_name, config) in enumerate(fields.items()):
            # field_name이 "source_language"이면 건너뛰도록 수정할 필요는 없음. fields 딕셔너리에서 이미 제거됨.
            ttk.Label(self.entry_fields_frame, text=config["label"]).grid(row=i, column=0, sticky=tk.NW, padx=5, pady=2) # row 인덱스는 fields 순서대로
            if config["widget"] == tk.Text:
                widget = tk.Text(self.entry_fields_frame, height=config["height"], width=50, wrap=tk.WORD)
            elif config["widget"] == ttk.Spinbox:
                widget = ttk.Spinbox(self.entry_fields_frame, width=48, **config.get("extra_args", {}))
            else: # ttk.Entry
                widget = ttk.Entry(self.entry_fields_frame, width=50)

            if config.get("readonly"):
                widget.config(state=tk.DISABLED)
            widget.grid(row=i, column=1, sticky=tk.EW, padx=5, pady=2)
            self.entry_widgets[field_name] = widget
      
        # Bottom: Save/Cancel buttons
        buttons_frame = ttk.Frame(self, padding="10")
        buttons_frame.pack(side=tk.BOTTOM, fill=tk.X)
        ttk.Button(buttons_frame, text="변경사항 저장 후 닫기", command=self._save_and_close).pack(side=tk.RIGHT, padx=5) # type: ignore
        ttk.Button(buttons_frame, text="현재 항목 저장", command=self._save_current_entry_button_action).pack(side=tk.RIGHT, padx=5)
        ttk.Button(buttons_frame, text="취소", command=self.destroy).pack(side=tk.RIGHT)
        
        replace_buttons_frame = ttk.Frame(self.entry_fields_frame)
        replace_buttons_frame.grid(row=i + 1, column=0, columnspan=2, pady=10, sticky="ew")
        ttk.Button(replace_buttons_frame, text="선택한 용어 치환", command=self._replace_selected_term).pack(side=tk.LEFT, padx=5)
        ttk.Button(replace_buttons_frame, text="모든 용어 치환", command=self._replace_all_terms).pack(side=tk.LEFT, padx=5)

        self._populate_listbox()
        if self.glossary_data: # Var name changed            
            self.listbox.selection_set(0)
            self._load_entry_to_fields(0)
        else:
            self._clear_entry_fields()

    def _replace_all_terms(self):
        if not self.input_file_path or not os.path.exists(self.input_file_path):
            messagebox.showerror("오류", "입력 파일 경로가 유효하지 않습니다. 입력 파일을 선택해주세요.", parent=self)
            return

        if not self.glossary_data:
            messagebox.showinfo("정보", "치환할 용어집 데이터가 없습니다.", parent=self)
            return

        if not messagebox.askyesno("전체 치환 확인", f"총 {len(self.glossary_data)}개의 용어를 파일 전체에서 치환하시겠습니까?\n이 작업은 되돌릴 수 없습니다.", parent=self):
            return

        try:
            with open(self.input_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            messagebox.showerror("파일 읽기 오류", f"파일을 읽는 중 오류가 발생했습니다: {e}", parent=self)
            return

        total_replacements = 0
        # Sort by length of keyword, descending, to replace longer words first
        sorted_glossary = sorted(self.glossary_data, key=lambda x: len(x.get("keyword", "")), reverse=True)

        for entry in sorted_glossary:
            keyword = entry.get("keyword")
            translated_keyword = entry.get("translated_keyword")

            if not keyword or not translated_keyword:
                continue
            
            # Use word boundaries to avoid replacing parts of words
            pattern = re.escape(keyword)
            new_content, num_replacements = re.subn(pattern, translated_keyword, content)
            
            if num_replacements > 0:
                content = new_content
                total_replacements += num_replacements

        try:
            with open(self.input_file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            messagebox.showinfo("치환 완료", f"총 {total_replacements}개의 단어가 성공적으로 치환되었습니다.", parent=self)
        except Exception as e:
            messagebox.showerror("파일 쓰기 오류", f"파일을 저장하는 중 오류가 발생했습니다: {e}", parent=self)

    def _replace_selected_term(self):
        if self.current_selection_index is None:
            messagebox.showinfo("정보", "치환할 용어를 선택해주세요.", parent=self)
            return

        if not self.input_file_path or not os.path.exists(self.input_file_path):
            messagebox.showerror("오류", "입력 파일 경로가 유효하지 않습니다. 입력 파일을 선택해주세요.", parent=self)
            return

        entry = self.glossary_data[self.current_selection_index]
        keyword = entry.get("keyword")
        translated_keyword = entry.get("translated_keyword")

        if not keyword or not translated_keyword:
            messagebox.showerror("오류", "선택된 항목에 키워드 또는 번역된 키워드가 없습니다.", parent=self)
            return

        if len(keyword) == 1:
            if not messagebox.askyesno("경고", "한 글자로 된 용어를 치환할 경우, 문맥상 오류가 발생할 가능성이 높습니다. 그래도 바꾸시겠습니까?", parent=self):
                return

        if not messagebox.askyesno("치환 확인", f"'{keyword}'을(를) '{translated_keyword}'(으)로 치환하시겠습니까?", parent=self):
            return

        try:
            with open(self.input_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            messagebox.showerror("파일 읽기 오류", f"파일을 읽는 중 오류가 발생했습니다: {e}", parent=self)
            return

        pattern = re.escape(keyword)
        new_content, num_replacements = re.subn(pattern, translated_keyword, content)

        if num_replacements == 0:
            messagebox.showinfo("정보", f"'{keyword}'을(를) 파일에서 찾을 수 없습니다.", parent=self)
            return

        try:
            with open(self.input_file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            messagebox.showinfo("치환 완료", f"{num_replacements}개의 단어가 성공적으로 치환되었습니다.", parent=self)
        except Exception as e:
            messagebox.showerror("파일 쓰기 오류", f"파일을 저장하는 중 오류가 발생했습니다: {e}", parent=self)

    def _populate_listbox(self):
        self.listbox.delete(0, tk.END)
        for i, entry in enumerate(self.glossary_data): # Var name changed          
            self.listbox.insert(tk.END, f"{i:03d}: {entry.get('keyword', 'N/A')}")

    def _on_listbox_select(self, event):
        selection = self.listbox.curselection()
        if not selection:
            # 사용자가 리스트박스의 빈 공간을 클릭하여 선택이 해제된 경우
            if self.current_selection_index is not None:
                self._save_current_entry() # Save data of the item that was deselected
            self._clear_entry_fields()
            self.current_selection_index = None # Update state
            return


        # 여기까지 왔다면, selection이 비어있지 않음
        new_index = selection[0] 


        # If there was a previously selected item and it's different from the new one
        if self.current_selection_index is not None and self.current_selection_index != new_index:
            if not self._save_current_entry(): # Save the old item's data
                # If save failed (e.g. validation), revert selection to the old item
                if self.current_selection_index is not None: # Ensure index is valid
                    self.listbox.selection_set(self.current_selection_index) # type: ignore              
                # Do not proceed to load the new_index if saving the old one failed.
                return 
        
        # Load the newly selected item's data into entry fields
        self._load_entry_to_fields(new_index)
        # self.current_selection_index is updated inside _load_entry_to_fields

    def _load_entry_to_fields(self, index: int):
        if not (0 <= index < len(self.glossary_data)): # Var name changed           
            self._clear_entry_fields()
            return

        entry = self.glossary_data[index]
        for field_name, widget in self.entry_widgets.items():
            value = entry.get(field_name)
            if isinstance(widget, tk.Text):
                is_readonly = widget.cget("state") == tk.DISABLED
                if is_readonly: widget.config(state=tk.NORMAL)             
                widget.delete('1.0', tk.END)
                widget.insert('1.0', str(value) if value is not None else "")
                if is_readonly: widget.config(state=tk.DISABLED)
            elif isinstance(widget, ttk.Entry):
                widget.delete(0, tk.END)
                widget.insert(0, str(value) if value is not None else "")
            elif isinstance(widget, ttk.Spinbox):
                widget.set(str(value) if value is not None else "0")
            elif isinstance(widget, ttk.Checkbutton):
                self.is_spoiler_var.set(bool(value))
        self.current_selection_index = index # Ensure this is set after loading


    def _clear_entry_fields(self):
        for field_name, widget in self.entry_widgets.items():
            if isinstance(widget, tk.Text):
                is_readonly = widget.cget("state") == tk.DISABLED
                if is_readonly: widget.config(state=tk.NORMAL)
                widget.delete('1.0', tk.END)
                if is_readonly: widget.config(state=tk.DISABLED)
            elif isinstance(widget, ttk.Entry):
                widget.delete(0, tk.END)
            elif isinstance(widget, ttk.Spinbox):
                widget.set("0")
        self.current_selection_index = None
        if "keyword" in self.entry_widgets:
            self.entry_widgets["keyword"].focus_set()

    def _save_current_entry_button_action(self):
        idx = self.current_selection_index
        if idx is not None:
            if self._save_current_entry(): # _save_current_entry now doesn't re-select
                # After saving, ensure the (potentially updated) item remains selected
                self.listbox.selection_set(idx)
                self.listbox.see(idx) # Ensure it's visible

    def _save_current_entry(self) -> bool: # Added return type
        if self.current_selection_index is None or not (0 <= self.current_selection_index < len(self.glossary_data)): # Var name changed
            return True # Nothing to save if no valid selection

        index_to_save = self.current_selection_index
        if not (0 <= index_to_save < len(self.glossary_data)): return True # Var name changed

        updated_entry: Dict[str, Any] = {}
        for field_name, widget_instance in self.entry_widgets.items():
            if isinstance(widget_instance, tk.Text):
                updated_entry[field_name] = widget_instance.get('1.0', tk.END).strip()
            elif isinstance(widget_instance, ttk.Entry):
                updated_entry[field_name] = widget_instance.get().strip()
            elif isinstance(widget_instance, ttk.Spinbox):
                try:
                    updated_entry[field_name] = int(widget_instance.get())
                except ValueError:
                    updated_entry[field_name] = 0 

        if not updated_entry.get("keyword") or not updated_entry.get("translated_keyword") or \
           not updated_entry.get("target_language"): # source_language 필드 제거에 따른 유효성 검사 조건 변경
            messagebox.showwarning("경고", "키워드, 번역된 키워드, 도착 언어는 비워둘 수 없습니다.", parent=self) # 메시지 명확화
            self.entry_widgets["keyword"].focus_set()
            return False

        # Get the old display text from the listbox before updating the data
        # This is to check if the listbox item's text actually needs to be changed
        old_listbox_text = self.listbox.get(index_to_save)

        self.glossary_data[index_to_save] = updated_entry # Var name changed
        
        # Update only the specific listbox item if its display text changed
        new_listbox_text = f"{index_to_save:03d}: {updated_entry.get('keyword', 'N/A')}"
        if old_listbox_text != new_listbox_text:
            self.listbox.delete(index_to_save)
            self.listbox.insert(index_to_save, new_listbox_text)

        # REMOVED: self.listbox.selection_set(index_to_save) # Re-select
        return True

    def _add_new_entry(self):
        if self.current_selection_index is not None: # If an item is selected
            if not self._save_current_entry(): # Try to save it first
                return # Don't add new if save failed (e.g. validation)
        
        self._clear_entry_fields()
        # Create a new blank entry and add it to the data
        new_entry_template = {
            "keyword": "", "translated_keyword": "", 
            "target_language": "",
            "occurrence_count": 0
        }
        self.glossary_data.append(new_entry_template) # Var name changed
        self._populate_listbox()
        new_index = len(self.glossary_data) - 1 # Var name changed
        self.listbox.selection_set(new_index)
        self.listbox.see(new_index)
        self._load_entry_to_fields(new_index)
        self.entry_widgets["keyword"].focus_set()

    def _delete_selected_entry(self):
        if self.current_selection_index is None:
            messagebox.showwarning("경고", "삭제할 항목을 선택하세요.", parent=self)
            return

        if messagebox.askyesno("삭제 확인", f"'{self.glossary_data[self.current_selection_index].get('keyword')}' 항목을 정말 삭제하시겠습니까?", parent=self): # Var name changed
            del self.glossary_data[self.current_selection_index] # Var name changed
            self._populate_listbox()
            self._clear_entry_fields()
            if self.glossary_data: # If list is not empty, select first item # Var name changed
                self.listbox.selection_set(0)
                self._load_entry_to_fields(0)

    def _save_and_close(self):
        if self.current_selection_index is not None: # If an item is selected or was being edited
            if not self._save_current_entry(): # Try to save the currently edited/new item
                if not messagebox.askokcancel("저장 오류", "현재 항목 저장에 실패했습니다 (예: 키워드 누락). 저장하지 않고 닫으시겠습니까?", parent=self):
                    return

        # Filter out any entries that might have been added but left with an empty keyword
        self.glossary_data = [entry for entry in self.glossary_data if entry.get("keyword", "").strip()] # Var name changed

        final_json_str = json.dumps(self.glossary_data, indent=2, ensure_ascii=False) # Var name changed
        self.save_callback(final_json_str)
        self.destroy()


class TextHandler(logging.Handler):
    def __init__(self, text_widget: scrolledtext.ScrolledText): # type: ignore
        super().__init__() # Corrected indentation
        self.text_widget = text_widget
        self.text_widget.tag_config("INFO", foreground="black")
        self.text_widget.tag_config("DEBUG", foreground="gray")
        self.text_widget.tag_config("WARNING", foreground="orange")
        self.text_widget.tag_config("ERROR", foreground="red", font=('Helvetica', 9, 'bold'))
        self.text_widget.tag_config("CRITICAL", foreground="red", background="yellow", font=('Helvetica', 9, 'bold'))
        self.text_widget.tag_config("TQDM", foreground="blue") 

    def emit(self, record: logging.LogRecord): # Corrected indentation relative to class
        msg = self.format(record)
        level_tag = record.levelname
        
        def append_message_to_widget():
            try:
                if not self.text_widget.winfo_exists(): 
                    return
                
                current_state = self.text_widget.cget("state") 
                self.text_widget.config(state=tk.NORMAL) 
                self.text_widget.insert(tk.END, msg + "\n", level_tag)
                self.text_widget.config(state=current_state) 
                self.text_widget.see(tk.END)
            except tk.TclError:
                # This can happen if the window is destroyed.
                pass 

        if self.text_widget.winfo_exists():
             self.text_widget.after(0, append_message_to_widget)

if __name__ == '__main__':
    logger.info("BatchTranslatorGUI 시작 중...")

    # ttkbootstrap.Window 사용
    root = ttk.Window(themename="litera") # 'litera' 테마 적용, 다양한 테마 선택 가능 (예: cosmo, flatly, journal, darkly 등)
    
    try:
        app_gui = BatchTranslatorGUI(root)
    except Exception as e:
        logger.critical(f"GUI 초기화 중 치명적 오류 발생: {e}", exc_info=True)
        try:
            messagebox.showerror("치명적 오류", f"애플리케이션을 시작할 수 없습니다: {e}")
        except tk.TclError: 
            print(f"CRITICAL ERROR during GUI initialization: {e}")
        
        if root.winfo_exists(): 
            root.destroy()
        exit(1) 

    root.mainloop()
    logger.info("BatchTranslatorGUI 종료됨.")
            </code></pre>
        </section>

        <!-- 설정 파일 (config.json) -->
        <section id="config-file">
            <h2 class="text-3xl font-bold text-gray-900 border-b pb-2 mb-6">설정 파일 (config.json)</h2>
            <p class="text-gray-700 leading-relaxed mb-4">
                GUI에서 설정을 저장하거나 <code>config.json</code> 파일을 직접 수정하여 프로그램의 기본 동작을 제어할 수 있습니다.
                다음은 주요 설정 키 목록입니다.
            </p>
            <pre class="bg-gray-900 text-white p-4 rounded-lg overflow-x-auto font-mono text-sm"><code>{
    // --- 1. 인증 (Authentication) ---
    "api_keys": [
        "your_gemini_api_key_1",
        "your_gemini_api_key_2"
    ],
    "use_vertex_ai": false,
    "service_account_file_path": null, // "C:/path/to/service-account.json"
    "gcp_project": null, // "your-gcp-project-id"
    "gcp_location": null, // "asia-northeast3"

    // --- 2. 모델 및 생성 (Model & Generation) ---
    "model_name": "gemini-2.0-flash",
    "temperature": 0.7,
    "top_p": 0.9,
    "thinking_budget": null, // (옵션) Flash: 0-24576, Pro: 128-32768
    
    // --- 3. 처리 설정 (Processing) ---
    "chunk_size": 3000,
    "max_workers": 4,
    "requests_per_minute": 10.0, // 분당 API 요청 수 (0 또는 null = 제한 없음)

    // --- 4. 언어 및 프롬프트 (Language & Prompts) ---
    "novel_language": "auto", // 번역 출발 언어 (예: "ja", "en", "auto")
    "novel_language_fallback": "zh", // "auto" 실패 시 사용할 언어
    "prompts": "# 용어집...\n{{glossary_context}}\n\n## 번역할 원문\n\n<main id=\"content\">{{slot}}</main>\n\n## 번역 결과 (한국어):",
    
    // --- 5. 프리필(Prefill) 설정 ---
    "enable_prefill_translation": true,
    "prefill_system_instruction": "\n\n# system_settings\n- You are an expert professional translator...",
    "prefill_cached_history": [], // 예: [{"role": "user", "parts": ["Hello"]}, {"role": "model", "parts": ["Hi"]}]

    // --- 6. 용어집 (Glossary) ---
    "glossary_json_path": null, // "C:/path/to/my_glossary.json"
    "glossary_sampling_ratio": 10.0, // 추출 시 텍스트 샘플링 비율 (5.0 ~ 100.0)
    "glossary_extraction_temperature": 0.3,
    "user_override_glossary_extraction_prompt": "", // 비워두면 기본 프롬프트 사용

    // --- 7. 동적 용어집 주입 (Dynamic Injection) ---
    "enable_dynamic_glossary_injection": false, // true로 설정 시 번역 프롬프트에 용어집 주입
    "max_glossary_entries_per_chunk_injection": 3,
    "max_glossary_chars_per_chunk_injection": 500,

    // --- 8. 안전 및 후처리 (Safety & Post-processing) ---
    "use_content_safety_retry": true,
    "max_content_safety_split_attempts": 3,
    "min_content_safety_chunk_size": 100,
    "enable_post_processing": true
}
</code></pre>
        </section>

        <!-- AI 상담사 (신규 섹션) -->
        <section id="ai-chat-guide">
            <h2 class="text-3xl font-bold text-gray-900 border-b pb-2 mb-6">AI 상담사</h2>
            <p class="text-gray-700 leading-relaxed mb-6">
                이 매뉴얼과 상단 '코드 라이브러리'의 소스 코드에 대해 궁금한 점을 AI에게 직접 물어보세요.
            </p>
            
            <!-- 높이 수정: h-[70vh] -> h-[80vh], max-h-[600px] 제거 -->
            <div class="bg-white rounded-lg shadow-sm border border-gray-200 flex flex-col h-[80vh] bg-white rounded-lg shadow-xl border border-gray-200 z-50 flex flex-col transition-all duration-300 ease-in-out transform translate-y-4 opacity-0 sm:max-w-md" id="chat-window" style="opacity: 1; transform: none; position: relative; max-width: none;"> 
                <!-- 헤더 -->
                <div class="flex justify-between items-center p-4 border-b bg-indigo-50 rounded-t-lg">
                    <h3 class="text-xl font-bold text-indigo-700">BTG AI 상담사 채팅</h3>
                </div>
                <!-- 메시지 창 -->
                <div id="chat-messages" class="flex-1 p-4 overflow-y-auto space-y-4 scroll-smooth bg-gray-50">
                    <!-- 초기 메시지 -->
                    <div class="flex justify-start">
                        <div class="p-3 bg-indigo-100 text-indigo-800 rounded-lg max-w-xs break-words md:max-w-md prose prose-sm max-w-full">
                            안녕하세요! BTG 매뉴얼과 소스 코드에 대해 무엇이든 물어보세요.
                        </div>
                    </div>
                </div>
                <!-- 입력 폼 -->
                <div class="p-4 border-t bg-gray-100 rounded-b-lg">
                    <div class="flex space-x-2">
                        <input type="text" id="chat-input" class="flex-1 border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="질문을 입력하세요...">
                        <button id="chat-send" class="bg-indigo-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-indigo-700 transition duration-300 disabled:opacity-50">전송</button>
                    </div>
                </div>
            </div>
        </section>


        <!-- 라이선스 -->
        <section id="license">
            <h2 class="text-3xl font-bold text-gray-900 border-b pb-2 mb-6">라이선스</h2>
            <div class="bg-white p-6 rounded-lg shadow-sm border">
                <h3 class="text-xl font-semibold text-gray-800 mb-4">MIT License</h3>
                <p class="text-gray-600 mb-4">Copyright (c) 2025 Hyunwoo_Room</p>
                <p class="text-sm text-gray-600 leading-relaxed mb-4">
                    Permission is hereby granted, free of charge, to any person obtaining a copy
                    of this software and associated documentation files (the "Software"), to deal
                    in the Software without restriction, including without limitation the rights
                    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                    copies of the Software, and to permit persons to whom the Software is
                    furnished to do so, subject to the following conditions:
                </p>
                <p class="text-sm text-gray-600 leading-relaxed mb-4">
                    The above copyright notice and this permission notice shall be included in all
                    copies or substantial portions of the Software.
                </p>
                <p class="text-sm text-gray-600 leading-relaxed font-semibold">
                    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                    SOFTWARE.
                </p>
            </div>
        </section>

    </main>

    <!-- AI 상담사 채팅 버튼 (삭제됨) -->
    <!--
    <button id="chat-fab" class="fixed bottom-8 right-8 bg-indigo-600 text-white p-4 rounded-full shadow-lg hover:bg-indigo-700 transition duration-300 z-50">
        ...
    </button>
    -->

    <!-- AI 상담사 채팅 창 (삭제됨) -->
    <!--
    <div id="chat-window" class="fixed bottom-24 right-8 w-full max-w-lg h-[70vh] bg-white rounded-lg shadow-xl border border-gray-200 z-50 flex flex-col hidden transition-all duration-300 ease-in-out transform translate-y-4 opacity-0 sm:max-w-md">
        ...
    </div>
    -->


    <!-- 스크롤 감지 및 사이드바 활성화/모바일 메뉴 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            // --- 모바일 메뉴 토글 ---
            const menuButton = document.getElementById('menu-button');
            const mobileSidebar = document.getElementById('mobile-sidebar');
            const overlay = document.getElementById('overlay');
            const tocLinksMobile = document.querySelectorAll('#mobile-toc a');

            function toggleMenu() {
                mobileSidebar.classList.toggle('-translate-x-full');
                overlay.classList.toggle('hidden');
            }

            menuButton.addEventListener('click', toggleMenu);
            overlay.addEventListener('click', toggleMenu);
            tocLinksMobile.forEach(link => {
                link.addEventListener('click', toggleMenu);
            });

            // --- 데스크탑 스크롤 스파이 ---
            const sections = document.querySelectorAll('main section');
            const tocLinks = document.querySelectorAll('#toc a');
            
            const observerOptions = {
                root: null, // 뷰포트 기준
                rootMargin: '0px',
                threshold: 0.3 // 섹션이 30% 보일 때
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const id = entry.target.getAttribute('id');
                        tocLinks.forEach(link => {
                            link.classList.remove('active');
                            if (link.getAttribute('href') === `#${id}`) {
                                link.classList.add('active');
                            }
                        });
                    }
                });
            }, observerOptions);

            sections.forEach(section => {
                observer.observe(section);
            });

            // 모바일 TOC 링크에도 active 클래스 적용 (간단한 버전)
             const mobileObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const id = entry.target.getAttribute('id');
                        document.querySelectorAll('#mobile-toc a').forEach(link => {
                            link.classList.remove('active');
                            if (link.getAttribute('href') === `#${id}`) {
                                link.classList.add('active');
                            }
                        });
                    }
                });
            }, observerOptions);

            sections.forEach(section => {
                mobileObserver.observe(section);
            });

            // --- AI 상담사 챗봇 로직 ---
            // const chatFab = document.getElementById('chat-fab'); (삭제)
            // const chatWindow = document.getElementById('chat-window'); (삭제)
            // const closeChat = document.getElementById('close-chat'); (삭제)
            const chatMessages = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const chatSend = document.getElementById('chat-send');

            let sourceCodeContext = ""; // 소스 코드 컨텍스트를 저장할 변수

            // 1. 소스 코드 컨텍스트 빌드
            function buildSourceCodeContext() {
                const codeBlocks = document.querySelectorAll('pre[data-filename]');
                let context = "";
                codeBlocks.forEach(block => {
                    const filename = block.getAttribute('data-filename');
                    const code = block.querySelector('code').innerText;
                    context += `\n\n--- FILE: ${filename} ---\n\n${code}\n\n--- END FILE: ${filename} ---`;
                });
                return context;
            }

            // 페이지 로드 시 컨텍스트 빌드
            sourceCodeContext = buildSourceCodeContext();
            console.log(`AI 컨텍스트 빌드 완료: ${sourceCodeContext.length}자`);
            
            // 디버깅용: 컨텍스트 전체 내용 콘솔 출력
            console.log("--- Source Code Context Start ---");
            console.log(sourceCodeContext);
            console.log("--- Source Code Context End ---");

            // 2. 챗봇 UI 토글 (삭제)
            /*
            function toggleChatWindow() {
                chatWindow.classList.toggle('hidden');
                if (!chatWindow.classList.contains('hidden')) {
                    chatWindow.classList.remove('opacity-0', 'translate-y-4');
                    chatInput.focus();
                } else {
                    chatWindow.classList.add('opacity-0', 'translate-y-4');
                }
            }
            chatFab.addEventListener('click', toggleChatWindow);
            closeChat.addEventListener('click', toggleChatWindow);
            */

            // 3. 메시지 전송 처리
            chatSend.addEventListener('click', handleChatSend);
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleChatSend();
                }
            });

            function handleChatSend() {
                const query = chatInput.value.trim();
                if (query === "") return;

                addMessage(query, 'user');
                chatInput.value = "";
                showLoading(true);

                callGeminiAPI(query);
            }

            // 4. 메시지 UI 추가
            function addMessage(message, sender) {
                const messageWrapper = document.createElement('div');
                const messageElement = document.createElement('div');
                
                messageWrapper.classList.add('flex');
                messageElement.classList.add('p-3', 'rounded-lg', 'max-w-xs', 'break-words', 'md:max-w-md');

                if (sender === 'user') {
                    messageWrapper.classList.add('justify-end');
                    messageElement.classList.add('bg-indigo-600', 'text-white');
                    // 사용자 메시지는 일반 텍스트로 설정
                    messageElement.innerText = message;
                } else {
                    messageWrapper.classList.add('justify-start');
                    // `prose`: Tailwind의 타이포그래피 플러그인. HTML을 예쁘게 렌더링.
                    // `prose-sm`: 채팅창에 맞게 작은 글꼴 크기.
                    // `max-w-full`: `prose`가 기본적으로 `max-width`를 설정하는 것을 방지.
                    messageElement.classList.add('bg-indigo-100', 'text-indigo-800', 'prose', 'prose-sm', 'max-w-full');
                    
                    // marked.parse()가 마크다운 문자열을 HTML로 변환
                    // .innerHTML이 변환된 HTML을 렌더링
                    // AI의 응답에 포함된 코드 블록, 리스트, 볼드체 등이 HTML로 변환됩니다.
                    messageElement.innerHTML = marked.parse(message);
                }
                
                /*
                // 이 블록은 위 if/else 내부로 병합되었으므로 제거됨
                if (sender === 'user') {
                     messageElement.innerText = message;
                }
                */

                messageWrapper.appendChild(messageElement);
                chatMessages.appendChild(messageWrapper);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            // 5. 로딩 인디케이터
            function showLoading(isLoading) {
                let loadingElement = document.getElementById('loading-indicator');
                if (isLoading) {
                    if (!loadingElement) {
                        const wrapper = document.createElement('div');
                        wrapper.id = 'loading-indicator';
                        wrapper.classList.add('flex', 'justify-start');
                        wrapper.innerHTML = `
                            <div class="p-3 bg-indigo-100 text-indigo-800 rounded-lg max-w-xs">
                                <div class="flex items-center space-x-2">
                                    <div class="w-2 h-2 bg-indigo-400 rounded-full animate-pulse" style="animation-delay: 0s;"></div>
                                    <div class="w-2 h-2 bg-indigo-400 rounded-full animate-pulse" style="animation-delay: 0.2s;"></div>
                                    <div class="w-2 h-2 bg-indigo-400 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
                                </div>
                            </div>
                        `;
                        chatMessages.appendChild(wrapper);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                    chatSend.disabled = true;
                } else {
                    if (loadingElement) {
                        loadingElement.remove();
                    }
                    chatSend.disabled = false;
                    chatInput.focus();
                }
            }

            // 6. Gemini API 호출
            async function callGeminiAPI(query, retries = 3, delay = 1000) {
                const apiKey = ""; // API 키는 런타임에 자동 제공됩니다.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

                const systemPrompt = `
안녕하세요! 저는 BTG(배치 번역기) 사용을 도와드리는 AI 상담사입니다.
사용자분께서 궁금해하시는 BTG 프로그램의 사용법이나 기능, 그리고 프로그램 내부의 소스 코드 내용에 대해 답변해 드릴 수 있습니다.

저는 인터넷 검색 대신, 아래에 제공된 **BTG 프로그램의 실제 소스 코드와 설명서 내용**만을 참고하여 답변합니다.
따라서 제가 답변하는 모든 내용은 이 프로그램에 실제로 구현된 기능과 로직에 기반합니다.

답변을 드릴 때는 다음과 같은 원칙을 따릅니다:
1.  **친절하고 알기 쉽게 설명합니다:** 어려운 개발 용어보다는 사용자가 이해하기 쉬운 표현을 사용합니다.
2.  **근거를 제시합니다:** 답변의 근거가 되는 소스 코드 파일명이나 함수, 로직 등을 함께 언급하여 신뢰성을 높입니다. (예: "app_service.py 파일의 start_translation 함수를 보면...")
3.  **모르는 내용은 솔직하게 말합니다:** 제공된 코드나 설명서에 없는 내용이라면, "죄송하지만 제공된 정보에는 해당 내용이 없습니다."라고 정직하게 답변합니다.
4.  **한국어로 답변합니다:** 모든 답변은 한국어로 제공합니다.

이제 궁금하신 점을 자유롭게 물어봐 주세요!

# 참고할 BTG 소스 코드 및 설명서 내용:
${sourceCodeContext}
`;

                const payload = {
                    contents: [{ parts: [{ text: query }] }],
                    systemInstruction: {
                        parts: [{ text: systemPrompt }]
                    },
                };

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429 && retries > 0) {
                            // Rate limit, retry with exponential backoff
                            console.warn(`Rate limit. Retrying in ${delay / 1000}s...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callGeminiAPI(query, retries - 1, delay * 2);
                        }
                        throw new Error(`API Error: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];
                    let aiResponse = "죄송합니다. 답변을 생성하는 데 실패했습니다.";

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        aiResponse = candidate.content.parts[0].text;
                    } else if (candidate && candidate.finishReason === 'SAFETY') {
                        aiResponse = "답변이 안전상의 이유로 차단되었습니다.";
                    }

                    showLoading(false);
                    addMessage(aiResponse, 'ai');

                } catch (error) {
                    console.error("Gemini API 호출 오류:", error);
                    if (retries > 0) {
                        console.warn(`Fetch error. Retrying in ${delay / 1000}s...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return callGeminiAPI(query, retries - 1, delay * 2);
                    }
                    
                    showLoading(false);
                    addMessage(`오류가 발생했습니다: ${error.message}`, 'ai');
                }
            }
        });
    </script>
</body>
</html>
